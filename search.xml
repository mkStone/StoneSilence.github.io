<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[个人的小小感悟]]></title>
    <url>%2F%E4%B8%AA%E4%BA%BA%E7%9A%84%E5%B0%8F%E5%B0%8F%E6%84%9F%E6%82%9F%2F</url>
    <content type="text"><![CDATA[@作者博客今天我准备回家了，家，是一个人最后的归属，而我同样如此。 此刻的享受着动车带来的速度视觉，一眼望去，如此之大的世界，为何我们连一个扎根落脚的地都这么难找？（有些人会说，我有啊，说实在的，你爸妈给你的，并不是你自己寻找的，都不曾属于自己的成就。） 昨天看到一个短片，里面描述着，我们都向往的生活。 故事开始！ 你尽管闭上眼睛，直到你29岁好了. 因为热爱，所以盲目，哪有什么理智可言。 耐心，每个人都用高处的标准来衡量现在的自己, 因为耐心可以为你提供承受风险的保护伞. 如果你既乐观又耐心，那么你成功上道了! 短片里说，那99%有所成就的人们，都无惧牺牲,坚持不懈,付出超过常人的努力.而且考虑的是50年，不是50天. 对人生的改变，何时都不晚！ 的确如此，我相信他最后说得话没错。 我们不是不想去改变现状，而是我们总是有各种的借口来逃避。 如果你失败了，不要怪别人，先从自己身上找原因。如果有天你成功了，看看那些跟你一起走过来的人。 我听我朋友说一过一句话:人如果感觉路不好走，很吃力，那么恭喜你，你在走上坡路。上坡路是你学习和成长的一个过程，如果你现在就轻松了，那么你老以后就走不动了。 我们要在年轻的时候，多去尝试一些从未经历的事情，让自己成长，让自己有着更多的阅历，让自己稍微领先一点。 各位一定要记住，没有什么不可能，如果你真的想去做的事情，先把最坏的结果想好，如果能承受，那么就去干，不要找借口，因为所有做不好事情的人，才会有各种各样的借口来推脱责任。 © 著作权归作者所有 转载请保留原链接地址]]></content>
  </entry>
  <entry>
    <title><![CDATA[Mybatis多表查询关系配置]]></title>
    <url>%2FMybatis%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%E5%85%B3%E7%B3%BB%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[@作者博客#### 后面有时间再写，睡觉了，明天还上班，又是忙碌和学习的一年，如果，技术稳定，去阿里做上几年，这辈子就不用再乱跑了！ © 著作权归作者所有 转载请保留原链接地址]]></content>
  </entry>
  <entry>
    <title><![CDATA[Mybatis介绍和原理]]></title>
    <url>%2FMybatis%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[@作者博客MyBatis 介绍-入门-原理 如上图所介绍的原理如下: 我的理解： ​ 首先加载Mbatis的配置文件，然后创建SqlSessionFactory. 再由SqlSessionFactory 得到 SqlSession对象， 而这个对象的出现，就是为了下面执行sql的对象。 mybatis底层自定义了Executor执行器接口操作数据库，Executor接口有两个实现，一个是基本执行器、一个是缓存执行器。 官方解释： Mybatis 对象使用范围 SqlSessionFactory SqlSession123456789SqlSession是一个面向用户的接口， sqlSession中定义了数据库操作方法。 每个线程都应该有它自己的SqlSession实例。SqlSession的实例不能共享使用，它也是线程不安全的。因此最佳的范围是请求或方法范围。绝对不能将SqlSession实例的引用放在一个类的静态字段或实例字段中。 打开一个 SqlSession；使用完毕就要关闭它。通常把这个关闭操作放到 finally 块中以确保每次都能执行关闭。如下： SqlSession session = sqlSessionFactory.openSession(); try &#123; // do work &#125; finally &#123; session.close(); &#125; Mybatis 的dao层开发，分为2种，一种是传统的 dao接口和实现类，还有一种是接口+Mapper动态代理对象1234567&lt;注意事项：Mapper接口开发方法只需要程序员编写Mapper接口（相当于Dao接口），由Mybatis框架根据接口定义创建接口的动态代理对象，代理对象的方法体同上边Dao接口实现类方法。Mapper接口开发需要遵循以下规范：1、 Mapper.xml文件中的namespace与mapper接口的类路径相同。2、 Mapper接口方法名和Mapper.xml中定义的每个statement的id相同 3、 Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同4、 Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同 代码实例: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354Public class UserMapperTest extends TestCase &#123; private SqlSessionFactory sqlSessionFactory; protected void setUp() throws Exception &#123; //mybatis配置文件 String resource = "sqlMapConfig.xml"; InputStream inputStream = Resources.getResourceAsStream(resource); //使用SqlSessionFactoryBuilder创建sessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); &#125; Public void testFindUserById() throws Exception &#123; //获取session SqlSession session = sqlSessionFactory.openSession(); //获取mapper接口的代理对象 UserMapper userMapper = session.getMapper(UserMapper.class); //调用代理对象方法 User user = userMapper.findUserById(1); System.out.println(user); //关闭session session.close(); &#125; @Test public void testFindUserByUsername() throws Exception &#123; SqlSession sqlSession = sqlSessionFactory.openSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); List&lt;User&gt; list = userMapper.findUserByUsername("张"); System.out.println(list.size()); &#125;Public void testInsertUser() throws Exception &#123; //获取session SqlSession session = sqlSessionFactory.openSession(); //获取mapper接口的代理对象 UserMapper userMapper = session.getMapper(UserMapper.class); //要添加的数据 User user = new User(); user.setUsername("张三"); user.setBirthday(new Date()); user.setSex("1"); user.setAddress("北京市"); //通过mapper接口添加用户 userMapper.insertUser(user); //提交 session.commit(); //关闭session session.close(); &#125; &#125; 配置内容12345678910111213SqlMapConfig.xml中配置的内容和顺序如下：properties（属性）settings（全局配置参数）typeAliases（类型别名）typeHandlers（类型处理器）objectFactory（对象工厂）plugins（插件）environments（环境集合属性对象） environment（环境子属性对象） transactionManager（事务管理） dataSource（数据源）mappers（映射器） 面试问题：在Mybatis中 #和$ 的区别： 123#占位符，防止注入$ 拼接符，不防注入 Mybatis 和Hibernate 对比 123虽然他们都是ORM框架，但是Mybatisqu并不是一个完整的ORM框架，因为你使用Hibernate可以完全不写sql语句,完全对java类型操作就可以了。那Mybatis是做不到的，使用Mybatis那你就必须写sql语句了.Hibernate 对sql优化就不是特别好了，因为它是关系映射,都是javaBean，不怎么好优化。如果，想灵活的开发，那就使用Mybatis，如果想提高开发效率就是会用Hibernate © 著作权归作者所有 转载请保留原链接地址]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95-%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[面试问题(技术总结)什么是SOA 分布式123456789集群：就是很多的服务器来实现一种功能，例如mysql，很多的服务器都安装mysql负载均衡：就是用来调节的，比方说有很多的用户都在访问读取数据，可是读取a服务器的mysql多，而读取别的服务器的mysql就少，负载均衡把访问a的用户转给b一部分，防止a由于访问量过大造成宕机什么的。分布式：一个系统把不同的服务分开来部署，用户模块，bbs论坛模块，内容模块，支付模块。对服务的访问量很大的时候，单台服务器已经满足不了需求，就把服务分散到几台甚至几十台几百天电脑上好处：每个模块只负责自己的事情和请求压力，开发人员只负责自己的东西分布式应用开发简单的说，是指将用户界面、控制台服务、数据库管理三个层次部署在不同的位置上。其中用户界面是客户端实现的功能，控制台服务是一个专门的服务器，数据管理是在一个专门的数据库服务器上实现的。 自我理解: 对项目的客户(用户界面),数据存储(操作数据(服务)),对数据库的操作(数据层) 分离开来,并且可以进行高效的敏捷开发. 分布式,可以对各个模块进行加强(服务器添加(集群处理)),把调用次数比较多的服务,多加服务器,哪些很少使用的服务,可以对它进行一个降低.1234567891011121314151617181920212223242526### hibernate和mybatis的区别- hibernate 是对SQL进行了高度的封装,它有自己的HQL语句- mybatis保留了对数据库灵活的操作,需要自己写sql语句- 他们都是ORM对象映射(数据查询出来以后都是存在pojo类中),使用方法都是大同小异.### hibernate的多个参数如何传递?怎么转换?- 自己理解 : - 数组传递,对HQL的语句进行拼接,in()里面的条件通过循环来判断.- 百度理解: - 集合(List),session.createSQLQuery(sql).setParameterList(&quot;userIdList&quot;, userIdList).list(); - 创建一个查询对象,并且,直接吧集合传进去即可.(setParameterList)### SpringMVC和struts2 的区别``` SpringMVC和struts2区别 实现不同 SpringMVC是通过Servlet来实现的 Struts2是通过拦截器来实现的 Json的转换方式不同 Spring MVC是自动转为json Struts2是通过插件来转 数据传输不同 SpringMVC是通过参数来传递的 Struts2是通过值栈来传递的,而值栈是个比较庞大的东西 控制器实例不同 SpringMVC是基于方法来实现的 Struts2是基于对象来实现的 SpringMVC从理论上来讲是比Struts2快的 四大域对象 ServletContext 生命周期：当WEB应用被加载进容器创建代表整个WEB应用的ServletContext对象，当服务器关闭或WEB应用被移除时，ServletContext对象跟着被销毁。 作用范围：整个WEB应用。 在不同Servlet之间转发、读取资源文件 Request域1.生命周期：在Service方法调用前由服务器创建，传入service发那个发。整个请求结束，request生命结束。2.作用范围：整个请求链（请求转发也存在）3.作用：在整个请求链中共享数据，经常用到：在servlet中处理好的数据交给JSP显示，此时参数就可以放在Request域中。 Session域 1.生命周期：在第一次调用request.getSession()方法时，服务器会检查是否已经有对应的session，如果没有就在内存中创建一个session并返回。当一段时间内session没有被使用（默认为30分钟），则服务器会销毁该session。如果服务器非正常关闭，没有到期的session也会跟着销毁。如果调用session提供的invalidate()，可以立即销毁session。 2.作用范围：一次会话。 PageContext域1.生命周期：当对JSP的请求开始，当相应结束时销毁。2.作用范围：整个JSP页面，是四大作用域中最小的一个。3.作用：获取其他八大隐式对象，可以认为是一个入口对象。`获取所有域中的数据`。 `跳转到其他资源`。 Spring 参数如何传递 直接把表单的参数写在Controller相应的方法的形参中，适用于get方式提交，不适用于post方式提交。 通过HttpServletRequest接收，post方式和get方式都可以。 通过一个bean来接收,post方式和get方式都可以。(也叫模型驱动) 通过@PathVariable获取路径中的参数 使用@ModelAttribute注解获取POST请求的FORM表单数据 用注解@RequestParam绑定请求参数到方法入参 Spring的特征 aop(面向切面编程): 软件系统分为两个部分：核心关注点和横切关注点 业务处理的主要流程是核心关注点 与之关系不大的部分是横切关注点 AOP核心概念 横切关注点切面（aspect）连接点（joinpoint）切入点（pointcut）通知（advice）目标对象织入（weave）引入（introduction） ioc(控制反转): IOC是一种思想,是一个重要的面向对象编程的体现之一 它是把创建和查找依赖对象的控制器交给了容器,有容器进行注入组合对象,所以对象与对象之间是,低耦合的,便于测试,而且也使得整个体系架构变得更灵活 就是对象找依赖并注入,而不是对象自己主动去找 IOC依赖注入 在控制反转中获取资源的过程叫做依赖注入-注入有2种,一种是通过xml配置进行构造注入-还有一种是通过setter注入,就是通过对象的set方法进行注入. 一般都是在Spring配置文件中,配置bean ,然后交给Spring自动注入,我们拿到对象就可以直接使用. Spring AOP (动态代理的实现)Spring MVC执行流程 自己理解: 客户请求–&gt;前端控制器–&gt;前端控制器找到HandlerAdapter–&gt;HandlerAdapter(处理数据)—&gt;返回视图–&gt;然后渲染视图–&gt;最后返回视图给客户Struts2的执行流程 Hibernate的执行流程mybatis的执行流程ElasticSearch 搭建ElasticSearch怎么建立索引ElasticSearch 怎么使用solr 搭建solr 怎么建立索引solr 怎么使用ActiveMQ 使用消费者:生产者: DobboWebServiceString &amp;&amp; StringBuffer 的区别,在什么时候使用.Nginx 负载均衡搭建Redis的搭建(集群)Redis 中的5种数据类型String：key-value（做缓存）Hash：key-fields-values（做缓存）SortedSet（zset）：有顺序，不能重复 © 著作权归作者所有 转载请保留原链接地址]]></content>
  </entry>
  <entry>
    <title><![CDATA[python爬虫入门]]></title>
    <url>%2Fpython%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[@作者博客今天,来介绍一下听起来很牛,其实的确牛的爬虫技术!(当然,我现在也学习者,分享一下学习经验) 废话不多少,先直接看效果 代码如下:文章URL爬取123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100import requestsimport pymysqldef waitSql(bookName,bookLink): bookName = str(bookName).replace(' ', '') bookName = str(bookName).replace('\r\n', '') db=pymysql.connect(host='localhost', port=3306, user='root', passwd='123', db='booklog',charset='utf8') # 使用 cursor() 方法创建一个游标对象 cursor cursor = db.cursor() # 使用 execute() 方法执行 SQL 查询 sql="insert into csdnbook(bookName,linkURL) VALUE('"+str(bookName)+"','"+str(bookLink)+"')" print(sql) cursor.execute(sql) db.commit() cursor.close() db.close() returndef getDiv(html): ####截取主要的文章链接块# divClass = html.find("article_list") divClassEnd=html.find("papelist",divClass)-38 ############截取到文章的块以后,把HTML内容重新赋值############# html=html[divClass:divClassEnd] #print(html) return htmldef Listadd(html): #进行html解析(首页解析) html=str(html) #获取文章块的文章(唯一标识哦!) divClass=html.find("article_list") #############循环查找每一个DIV(article_title)标签和 A标签里名的名字###################### while(divClass&gt;= -1): ##寻找主要的链接和文章名字的块,而不是全部链接 divClass=html.find('link_title',divClass) #寻找链接文章名字 if (divClass &lt;= -1): break a_=html.find('&lt;a href="',divClass)+9 _a=html.find('&gt;',a_)-1 #文章名字从链接获取完成以后开始 &lt;a&gt;名字&lt;/a&gt; 所以此刻的位置就是 _a +2的位置 # name_=html.find('',_a)+3 # _name=html.find('&lt;/a',name_) bookName_start = html.find('', _a) + 2 bookName_end = html.find('&lt;', bookName_start) #链接的的截取 url=html[a_:_a] #截取文章名字 Bookname=html[bookName_start:bookName_end] divClass = html.find("&lt;a href=",bookName_end) url="http://blog.csdn.net"+url #linkList.append(url) ###########查看获取到的数据########### ##去掉所有空格 Bookname.replace(" ","") url.replace(" ", "") #print(Bookname+url) ############添加到数据库########### waitSql(Bookname,url)def fileWarit(html,i): file=open(str(i)+'.html','w+',encoding='utf-8') file.write(html) file.close()#################请求循环,到25页,(分页请求)###############def geturl(): i=1 while(i&lt;=25): url="http://blog.csdn.net/u010870518/article/list/"+str(i) print(url) # # 写入User Agent信息 # head = &#123;&#125; # head[ # 'User-Agent'] = 'Mozilla/5.0 (Linux; Android 4.1.1; Nexus 7 Build/JRO03D) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.166 Safari/535.19' # 创建Request对象 web_date = requests.put(url) #把网页格式内容转换为 utf-8 web_date.encoding = 'utf-8' #####获取网页内容## html = web_date.text #fileWarit(html,i) ####使用 getDiv 方法把 html中文章的DIV 截取到# html = getDiv(html) #########链接添加到数据库########## Listadd(html) i=i+1###############################程序执行#####################geturl()#fileWarit(html) 文章爬取:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import pymysqlimport urllib.requestimport requestsimport time#######用来存储,数据库查询到的数据,名字,链接,时间###############NameList=[]urlList=[]datetime=[]#获取数据中,由CSDN 爬取到的文章 名字和链接def waitSql(): db=pymysql.connect(host='localhost', port=3306, user='root', passwd='admin', db='booklog',charset='utf8') # 使用 cursor() 方法创建一个游标对象 cursor cursor = db.cursor() # 使用 execute() 方法执行 SQL 查询 sql="select bookName,linkURL,dateTime from csdnbook" cursor.execute(sql) #获取数据库查询的数据 results=cursor.fetchall() for row in results: NameList.append(row[0]) urlList.append(row[1]) datetime.append(row[2]) #数组存数据 cursor.close() db.close() returndef getDiv(html): ####截取主要的文章链接块# divClass = html.find('&lt;div class="markdown_views"&gt;') divClassEnd=html.find('&lt;script type="text/javascript"&gt;',divClass) ############截取到文章的块以后,把HTML内容重新赋值############# html=html[divClass:divClassEnd] #print(html) return htmldef getDiv2(html): ####截取主要的文章链接块# divClass = html.find('&lt;div id="article_content"') divClassEnd=html.find('&lt;div class="bdsharebuttonbox tracking-ad',divClass)-45 ############截取到文章的块以后,把HTML内容重新赋值############# html=html[divClass:divClassEnd] #print(html) return htmldef waitr(name, html, time): # -*- coding: utf-8 -*- #################各种字符串 转换异常####################### name = str(name).replace('/', '') name = str(name).replace('\x08','') name = str(name).replace(':', '') name=str(name).replace('：', '') print(name) file = open(name + '.md','w+',encoding='utf8') head = "---\ntitle: " + name + "\ndate: " + str( time) + "\ntags: [javaEE]\nkeywords: " + name + ",Stone的博客\n---\n##### [@作者博客](http://www.1314sl.com)\n" Text = head + html print(Text) file.flush() file.write(Text) file.close() returnif __name__ == '__main__': waitSql() print(len(urlList)) print(len(NameList)) print(len(datetime)) for index in range(len(urlList)): web_data = requests.put(urlList[index]) web_data.encoding='utf-8' html=getDiv(web_data.text) if(html==""): print("###################245章以后的文章###########################") #######在245章以后文件的样式不同了###所以重新解析一下###### html=getDiv2(web_data.text) if(html==""): print(NameList[index]+"###############%%%%%%%%失败了%%%%%%%%%%%%%%%%################") continue waitr(NameList[index],html,datetime[index]) 好啦,装逼的时间过了,来介绍一下: 这次爬虫的目标是,中国最大的技术博客CSDN,不知道的朋友可以去百度. 首先,打开CSDN网站(http://blog.csdn.net/u010870518/article/list/1) 第二部就是解析这个网站的HTML结构. HTML主要的代码块,就在这个DIV里,我们打开这个DIV,再去寻找自己想要的数据. 点开以后发现,里面每一个DIV块,对于每一个文章入口.那就好操作了,现在已经找到它网站的有序结构就好爬取了. 它所有的URL都存在这个规定格式的a标签里,我们获取页面,然后利用pythone的来查找这个DIV块里的DIV块,然后获取a标签就可以了, 将获取到的链接,保存到数据库,即可. 然后再从数据库里获取就可以了! 这里就先介绍到这里.源码已经放在上面,喜欢的朋友可以试试. 本博客,所有的文章,仅供学习,请勿商业利用!本人概不负责! © 著作权归作者所有 转载请保留原链接地址]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux安装mysql]]></title>
    <url>%2FLinux%E5%AE%89%E8%A3%85mysql%2F</url>
    <content type="text"><![CDATA[@作者博客安装mysql Centos 下载mysql文件（5.6 linux-通用版） 上传到linux系统中 创建mysql的文件夹 解压到文件夹 (/usr/local/develop/mysql) 安装mysql的服务端 rpm -ivh MySQL-server-5.6.22-l.e16.i686.rpm 123456789101112131415161718如果上面的行不通，报错，就下载 mysql -glib.tar 版本的安装步骤：shell&gt; groupadd mysql # 添加用户组 mysqlshell&gt; useradd -r -g mysql mysql # 添加用户mysql 并加入到 mysql 组中shell&gt; cd /usr/local # 进入用户本地目录shell&gt; tar zxvf /path/to/mysql-VERSION-OS.tar.gz # 解压mysql压缩包(已解压略过)shell&gt; ln -s full-path-to-mysql-VERSION-OS mysql # 创建软连接 mysql 指定mysql**目录shell&gt; cd mysql # 进入mysql目录 ，或软连接目录shell&gt; chown -R mysql . # 更改当前目录下的所有文件的所属用户为 mysqlshell&gt; chgrp -R mysql . # 更改当前目录下的所有文件的所属组为 mysqlshell&gt; scripts/mysql_install_db --user=mysql # 开始安装(调用安装脚本)shell&gt; chown -R root .shell&gt; chown -R mysql data# Next command is optionalshell&gt; cp support-files/my-medium.cnf /etc/my.cnfshell&gt; bin/mysqld_safe --user=mysql &amp;# Next command is optionalshell&gt; cp support-files/mysql.server /etc/init.d/mysql.server Ubuntu 16.0 卸载 Mysql sudo apt purge mysql-* sudo rm -rf /etc/mysql/ /var/lib/mysql sudo apt autoremove sudo apt autoreclean Ubuntu16.0 安装Mysql安装5.61apt-get install software-properties-common 1234567891011121314151617181920212223sudo add-apt-repository &apos;deb http://archive.ubuntu.com/ubuntu trusty universe&apos;sudo apt-get updatesudo apt install mysql-server-5.6sudo apt install mysql-client-5.6查看服务：cd /etc/init.d/ls如果有mysql 就表示安装成功启动mysql：service mysql start停止mysql：service 服务名 start或stop&lt;!--如果你的mysql,不能远程连接,那你就开启远程服务!--&gt;开启远程服务：登录mysql:grant all privileges on *.* to &apos;root&apos; @&apos;%&apos; identified by &apos;admin&apos;;flush privileges;• 设置Linux的防火墙:/sbin/iptables -I INPUT -p tcp --dport 3306 -j ACCEPT/etc/rc.d/init.d/iptables save 123456Errors were encountered while processing:sudo -scd /var/cache/debconfrm *.datapt-get update &amp;&amp; apt-get upgrade 安装mysql 5.7 (最新)1234567891011121314151617181920212223242526272829sudo apt-get updatesudo apt-get install mysql-server系统将提示您在安装过程中创建 root 密码。选择一个安全的密码，并确保你记住它，因为你以后需要它。接下来，我们将完成 MySQL 的配置。sudo mysql_secure_installationsystemctl status mysql.service您将看到类似于以下内容的输出：mysql.service - MySQL Community ServerLoaded: loaded (/lib/systemd/system/mysql.service; enabled; vendor preset: en Active: active (running) since Wed 2016-11-23 21:21:25 UTC; 30min ago Main PID: 3754 (mysqld) Tasks: 28 Memory: 142.3M CPU: 1.994s CGroup: /system.slice/mysql.service └─3754 /usr/sbin/mysqld如果MySQL没有运行，您可以启动它：sudo systemctl mysql start如果额外的检查，您可以尝试使用该 mysqladmin 工具连接到数据库，该工具是允许您运行管理命令的客户端。例如，该命令表示以 root（-u root）方式连接到 MySQL ，提示输入密码（-p）并返回版本。mysqladmin -p -u root version你应该看到类似的输出：mysqladmin Ver 8.42 Distrib 5.7.16, for Linux on x86_64Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or its affiliates. Other names may be trademarks of their respective owners.Server version 5.7.16-0ubuntu0.16.04.1 Protocol version 10 Connection Localhost via UNIX socket UNIX socket /var/run/mysqld/mysqld.sock Uptime: 30 min 54 secThreads: 1 Questions: 12 Slow queries: 0 Opens: 115 Flush tables: 1 Open tables: 34 Queries per second avg: 0.006这意味着MySQL正在运行。结论现在您的服务器上已经安装了一个可以使用的 MySQL 5.7 了。 设置mysql 数据库 不区分大小写(项目上线)在my.cnf文件中: [mysqld] 后面添加: lower_case_table_names=1 © 著作权归作者所有 转载请保留原链接地址]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux环境搭建_Ubuntu]]></title>
    <url>%2FLinux%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-Ubuntu%2F</url>
    <content type="text"><![CDATA[@作者博客Ubuntu 16.0 安装jdk最快速,最装逼的安装方式直接在命令行里,运行,以下命令即可! sudo apt-get install default-jre 手动安装JDK 下载jdk 下载地址 利用工具上传到Ubuntu系统,我这里使用的是 FileZilla 解压到目录(/usr/local/java) 设置环境变量,修改配置文件 sudo vim ~/.bashrc在最后面加上：#set oracle jdk environmentexport JAVA_HOME=/usr/lib/jvm/jdk1.7.0_60 ## 要换成自己解压的jdk 目录export JRE_HOME=${JAVA_HOME}/jreexport CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/libexport PATH=${JAVA_HOME}/bin:$PATH 然后刷新配置文件 sudo vim ~/.bashrc 设置系统默认jdk 版本 第二个路径是你jdk安装的路径1234567下面是终端运行的代码,机制,第二个是你JDK解压的路径 sudo update-alternatives --install /usr/bin/java java /usr/local/jdk1.7.0_80/bin/java 300 sudo update-alternatives --install /usr/bin/javac javac /usr/local/jdk1.7.0_80/bin/javac 300 sudo update-alternatives --install /usr/bin/jar jar /usr/local/jdk1.7.0_80/bin/jar 300 sudo update-alternatives --install /usr/bin/javah javah /usr/local/jdk1.7.0_80/bin/javah 300 sudo update-alternatives --install /usr/bin/javap javap /usr/local/jdk1.7.0_80/bin/javap 300 sudo update-alternatives –config java (查看系统中有几个jdk，并且选择用哪个) © 著作权归作者所有 转载请保留原链接地址]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux环境搭建(JDK)]]></title>
    <url>%2FLinux%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-JDK%2F</url>
    <content type="text"><![CDATA[@作者博客Centos 装jdk 下载JDK 我这边下载的是 jdk1.7 上传文件（FileZilla) 在 /usr/local/ 目录下 创建 java mdkir /usr/local/java 安装 依赖 yum install glibc.i686 解压 jdk的包 tar -zxvf jdk_xxx.tar.gz -C /usr/local/java 配置 JDK的环境 vim /etc/profile （修改配置文件，跟Windows中环境变量一样） 12345678# set java environmentJAVA_HOME= JDK安装路径 (/usr/local/java/jdk1.7.0_80)CLASSPATH=.:$JAVA_HOME/lib.tools.jarPATH=$JAVA_HOME/bin:$PATHexport JAVA_HOME CLASSPATH PATH 重新加载配置文件 source /etc/profile 注意: 每个Linux的安装方式不同!同样的我也同时更新了Ubuntu16.0的jdk安装环境. © 著作权归作者所有 转载请保留原链接地址]]></content>
  </entry>
  <entry>
    <title><![CDATA[就业感言]]></title>
    <url>%2F%E5%B0%B1%E4%B8%9A%E6%84%9F%E8%A8%80%2F</url>
    <content type="text"><![CDATA[@作者博客杭州，这座城市，有多太的人想留下来，想要在这里干一个属于自己的落脚地。 而想要留下来，那你就必须干掉你的对手，我们都是刚刚毕业，培训出来，根本就没有实际的开发经验，而外面的技术，又是不断的更新，这个时候，一定要坚持下来！ 我也不瞒任何人，我在杭州一共面试45家！最后一家拿到office！ 最开始面试的时候，我还做下总结，最后索性就这样了！ 在面试的过程中，有跟面试官，聊得开心，各种扯，各种吹，也有跟面试官闹得不愉快！ 很想知道为什么闹得不愉快吧，当面试官问你Java基础的时候，你没有回答上来，并且啊，你很尴尬的时候，他们笑了，你就知道怎么个不舒服了。 被面试官质疑我技术的时候，我有段时间心态崩了，那个时候，是在杭州有15天了，跟我一起来杭州的还有2位同学，他们在那个时候，离开了杭州这座城市！ 为什么离开？因为这边的消耗，加上看不到一点希望的情况下，他们理性的选择了离开，而我并不甘心！ 为什么？为什么我来这里就找不到工作？为什么我的同学好多都找到了，而我却没有？然后你要面对的就是，你的朋友，你的家人，包括你的老师，他们都会问你，工作找的怎么样？ 我也想过跟我同学一样，选择离开。但是我不甘心啊，不甘心就这么放弃！每个人都不会觉得自己比别人差到到哪里去，可能比别人更好！ 你仔细想想，为什么去黑马，在哪里6个月，从早上的8点到晚上的10点甚至更能晚，我付出这么多，当我要实现，我的奋斗目标的时候，而你却给我来一个大锤子。那种感觉就像是，你看到一个大蛋糕，很多人都在分，而你好不容易挤进去，一看那块蛋糕，没了。。。 就这样，同学走了，并且只有自己一个人留在这里，开始我自己的人生路。 接下来的时间里，我比之前更疯狂，每天的面试都安排，并且能安排4个一天面试完的，我绝不安排3个。 在接下的面试中，我发现自己根本不需要在做任何的面试准备，跟面试官沟通都是一个小时左右。 哪个时候是准备还留一个星期再回去，可是到了下个星期，又不想回去了，总感觉，我离我的目标就差那么一点点，就又坚持了下来。 很幸运的是，拿到了我人生中的第一份office，并且顺利进入公司！ 请一定要记住,当你要放弃的时候,想想当初为什么来到这里!而我也是因为这样,才留在了杭州,这座美女如云的城市! 12345面试技巧： - 在自我介绍的时候，面试官想知道就是你项目的经验，和掌握的技术。 - 对于简历上写的技术，自己一定要掌握，并且了解Java基础的算法和底层。 - 对于 SSM 和SSH 都必须了解它们的区别，和为什么用它们！ - 在面试官问你还有什么想问我们公司的时候，你一定要问他们公司用什么技术，并且工作业务是什么。你问了，他就觉得，你对他们公司还是有想法的，并且最求技术！一般的面试官都会介绍他们的公司项目和业务！ 再给大家分享一些干货！在我的博客里，有些面试的经历，和面试问题的总结！百度搜索：Stone的博客 或者直接访问 www.1314sl.com © 著作权归作者所有 转载请保留原链接地址]]></content>
  </entry>
  <entry>
    <title><![CDATA[杭州面试总结-Stone_6家]]></title>
    <url>%2F%E6%9D%AD%E5%B7%9E%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93-Stone-6%E5%AE%B6%2F</url>
    <content type="text"><![CDATA[@作者博客到目前为止,我已经面试了6家左右 说句实在的,都不怎么样,虽然拿到一个office,但是不是很喜欢,我也不清楚是为啥,所以,来总一下问题 昨天,上午一家是 杭州华卓科技有限公司,进公司的第一感觉,前台的小姐姐,很标致啊,然后就是跟所有的面试一样,填一张表,然后就是等,面试官来面试.等得我实在是无聊啊,看到桌上有一个魔方,拿起来玩了. 哈哈哈,好了,总结一下,这家公司的情况: 他们主要负责的是医院那一块,就是他们要走互联网方向,什么远程看病啊,什么,什么的. 然后他们公司的开发框架 都是比较新进的框架,Spring boot,Spring Cloud 等等,还有一些我都没听过 然后面试官问我一些原理和底层问题,可惜啊,我对这一块并不是很了解,如果你让我写一段代码,可能还有一些希望. 然后我就大致说了一下 Spring MVC 的原理 大致就是: 用户请求–&gt;前端控制器–&gt;handlerAdapter–&gt;返回视图–&gt;渲染视图–&gt;把视图推送给用户 但是实际的答案是这样: 反正大致问的 比较细,也比较多.面试官还是很不错的,你不会的,或者说你答不上来的,他都会跟你说一遍那些原理.而且听他的语气来判断,这个人懂很多,而是技术宅那种吧,哈哈哈! 下午: 远昊科技有限公司 一进去我就懵逼了,我就说我来面试java开发工程师的,她们人事就来了 一句 “你是孙磊吧”,行吧,我当时都是懵逼的,对,没错,就我一个在那里面试,对就是我一个人… 一样的公司使用的框架也是SpringBoot,和Spring Cloud. 行吧,我应该是没戏了. 也没什么好说的,等下晚上再更新面试的技术总结,现在准备去面试了哈哈哈! © 著作权归作者所有 转载请保留原链接地址]]></content>
  </entry>
  <entry>
    <title><![CDATA[杭州面试问题总结-Stone]]></title>
    <url>%2F%E6%9D%AD%E5%B7%9E%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93-Stone%2F</url>
    <content type="text"><![CDATA[@作者博客此刻的我,享受着,咖啡+音乐 的生活,而在这么好的一个时间,我来了,我来给大家分享一下杭州的面试: 前天的一个总结: 到目前为止总共是面试了2家 情况是这样的第一家,是他们HR拿一个面试卷子 (里面的mybatis#和$的区别 不知道,就没有写)本类是想拍照的,可是我就坐在了HR旁边…. 面试官问我的我的问题 电商秒杀活动,如何实现,(一个用户,多端登陆,手机端,客户端,web端同时登陆)为了不让同一个用户抢购到同一个商品多次,我回答不上来,然后我就说 我在上个项目里是 用消息队列,进行实现,然后用Redis来缓解服务器压力. 然后又是那个问题 mybatis 的# 和$的区别 我说这个mybatis接触的不多,就上一个项目使用过. 然后又问我 hibernate 查询数据库的时候 ,如果有多个条件,就是in(参数….),怎么实现,我说得是,用数组,或者集合, 接着问,那它们怎么转换成参数?我回答:他们是自动转的. 然后问我上家公司的 薪资 我说12k 然后就是等通知.. 下午的这一家,技术总监没来,我进去的时候,他们让我在会议室等,然后我就装模作样的看了他们会议室上的一个宣告栏,是个什么 “帮你还”的APP软件,是关于信用卡还不上的那种人群使用.然后,他们HR面试我,问了我一些 上家公司的情况,和主要负责的业务 然后我问他,贵公司的主要业务和开发框架 他回答,业务这一块,我看你刚才也在看宣告栏,大概的业务就是,关于金额方面的数字问题 我回答: 我接触的金额,就是微信支付啊,支付宝啊,还有一些其他的第三方支付平台. 他就开始介绍他们公司和入职的薪资(6-8k 试用期,8-12k 转正薪资). 然后就没然后了,他就约我明天晚上6点去他们那边参加技术人员的面试,通过了就可以了. (他们现在是 做这个软件的后期维护,紧急事件处理,新成立的一个开发部,缺人!!!) 然后是对于技术的一些总结,我稍后整理出来!© 著作权归作者所有 转载请保留原链接地址]]></content>
  </entry>
  <entry>
    <title><![CDATA[拦截器,过滤器,监听器的区别]]></title>
    <url>%2F%E6%8B%A6%E6%88%AA%E5%99%A8-%E8%BF%87%E6%BB%A4%E5%99%A8-%E7%9B%91%E5%90%AC%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[@作者博客过滤器(Filter)(它是Servlet技术中最实用的技术) 一般是通过Filter来对请求(Request)对象和响应(Response)对象,进行拦截 在HttpServletRequest 到达 Servlet 之前，拦截客户的 HttpServletRequest 。 根据需要检查 HttpServletRequest ，也可以修改HttpServletRequest 头和数据。 在HttpServletResponse 到达客户端之前，拦截HttpServletResponse 。 根据需要检查 HttpServletResponse ，也可以修改HttpServletResponse头和数据 实现过滤 创建一个类,实现Filter接口,并重写doFilter方法 WEB服务器每次在调用web资源的service方法之前，都会先调用一下filter的doFilter方法 在 web.xml 文件中使用和进行配置 生命周期 Filter的创建和销毁由WEB服务器负责 web 应用程序启动时，web 服务器将创建Filter 的实例对象，并调用其init方法，读取web.xml配置，完成对象的初始化功能 * filter对象只会创建一次，init方法也只会执行一次 当用户访问与过滤器设置的URL的时候,Servlet会先走doFIle()方法 Filter对象,创建以后是跟随web服务器停止而销毁.处理乱码 在项目开发中,使用Spring框架的时候,前台的JSP页面和JAVA代码使用不同的字符集编码,从而导致 乱码. 而这个时候最好使用过滤器,在每次客户请求,在dofilter()方法中,处理乱码,那就不会出现乱码了,也不用每次获取值得时候,来转码了 Listener 监听器(3种监听)ServletContext监听ServletContextListener 用于对Servlet整个上下文进行监听(创建和销毁)ServletContextAttributeListener 对Servlet上下文属性的监听（增删改属性）。 Session监听HttpSessionListener接口：对Session的整体状态的监听。HttpSessionAttributeListener接口：对session的属性监听。 session超时，web.xml配置：12345&lt;session-config&gt; &lt;session-timeout&gt;120&lt;/session-timeout&gt;&lt;!--session120分钟后超时销毁--&gt;&lt;/session-config&gt; Request监听ServletRequestListener：用于对Request请求进行监听（创建、销毁）。ServletRequestAttributeListener：对Request属性的监听（增删改属性）。 监听器 既是对整个Servlet中,所有对象的创建和销毁监听,对对象的增删改,属性进行监听,如果有什么需求,是在某个对象创建的时候,要做的事情,那就在在对象创建的时候,实施监听,并且监听创建的方法里,做要做的事情 .同理,要是要对某个对象进行添加操作,而又想在控制台看见,那么一样的,在对象添加的时候,添加监听器,然后再添加前,只需要加一条输出语句即可拦截器(Interceptor) 与上面2个器不同的是,拦截器不属于Servlet,而是struts框架的 拦截器是基于Java反射机制实现的,这点跟JDK的动态代理有点像 java里的拦截器是动态拦截Action调用的对象，它提供了一种机制可以使开发者在一个Action执行的前后执行一段代码，也可以在一个Action 在AOP中，拦截器用于在某个方法或者字段被访问之前，进行拦截,然后再之前或者之后加入某些操作 (AOP介绍,请访问 www.1314sl.com 的 Spring两大特性) 当一个请求到 ServletDispatcher的时候,Struts2会查找配置文件，并根据配置实例化相对的拦截器对象,对相关的操作进行拦截,然后再执行具体方法前,添加你自己的处理操作,然后进入请求的具体方法 有点类似面向切片的技术(即AOP切面 是真的有点像) 总结:过滤器 在客户请求到服务器的时候,请求对象传入的request,Response,前,过滤掉一些信息,或者设置一些参数,在传入Servlet或者struts的Action处理. 监听器 监听器随web服务的启动而启动,WEB服务的停止而停止,Servlet监听器用于监听一些重要事件的发生，监听器对象可以在事情发生前、发生后可以做一些必要的处理。(比如某个对象的创建和销毁) 拦截器 拦截器是动态拦截Action调用的对象,并且在执行对象方法前,可以做一些操作,也可以添加一些功能.而不影响核心功能 思维导图如下: @作者博客 © 著作权归作者所有 转载请保留原链接地址 @作者博客]]></content>
      <tags>
        <tag>javaEE</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSH三大框架的工作原理及流程]]></title>
    <url>%2FSSH%E4%B8%89%E5%A4%A7%E6%A1%86%E6%9E%B6%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[SSH三大框架的工作原理及流程Hibernate工作原理及为什么要用? 原理 通过Configuration().configure();读取并解析hibernate.cfg.xml配置文件 由hibernate.cfg.xml中的&lt;mapping resource=&quot;com/xx/User.hbm.xml&quot;/&gt;读取并解析映射信息 通过config.buildSessionFactory();//创建SessionFactory .sessionFactory.openSession();//打开Sesssion .session.beginTransaction();//创建事务Transation persistent operate持久化操作 session.getTransaction().commit();//提交事务 .关闭Session 关闭SesstionFactory 为什么要用? 对JDBC访问数据库的代码做了封装，大大简化了数据访问层繁琐的重复性代码。 Hibernate是一个基于JDBC的主流持久化框架，是一个优秀的ORM实现。他很大程度的简化DAO层的编码工作 hibernate使用Java反射机制，而不是字节码增强程序来实现透明性。 hibernate的性能非常好，因为它是个轻量级框架。映射的灵活性很出色。它支持各种关系数据库，从一对一到多对多的各种复杂关系。 Hibernate的查询方式 Sql、Criteria,object comptosition Hql：1、 属性查询2、 参数查询、命名参数查询3、 关联查询4、 分页查询5、 统计函数 Struts工作机制？为什么要使用Struts Struts的工作流程: 在web应用 启动时就会加载初始化ActionServlet,ActionServlet从struts-config.xml文件中读取配置信息,把它们存放到各种配置对象当ActionServlet接收到一个客户请求时,将执行如下流程. 检索和用户请求匹配的ActionMapping实例,如果不存在,就返回请求路径无效信息;如果ActionForm实例不存在,就创建一个ActionForm对象,把客户提交的表单数据保存到ActionForm对象中; 根据配置信息决定是否需要表单验证.如果需要验证,就调用ActionForm的validate()方法; 如果ActionForm的validate()方法返回null或返回一个不包含ActionMessage的ActuibErrors对象, 就表示表单验证成功; ActionServlet根据ActionMapping所包含的映射信息决定将请求转发给哪个Action,如果相应的 Action实例不存在,就先创建这个实例,然后调用Action的execute()方法; Action的execute()方法返回一个ActionForward对象,ActionServlet在把客户请求转发给 ActionForward对象指向的JSP组件;-ActionForward对象指向JSP组件生成动态网页,返回给客户;为什么要用： JSP、Servlet、JavaBean技术的出现给我们构建强大的企业应用系统提供了可能。但用这些技术构建的系统非常的繁乱，所以在此之上，我们需要一个规则、一个把这些技术组织起来的规则，这就是框架，Struts便应运而生。 基于Struts开发的应用由3类组件构成：控制器组件、模型组件、视图组件 Sping 简单分析 Spring Web MVC 处理Http请求的大致过程： 一旦Http请求到来，DispatcherSevlet将负责将请求分发。 DispatcherServlet可以认为是Spring提供的前端控制器， 所有的请求都有经过它来统一分发。 在DispatcherServlet将请求分发给Spring Controller之前， 需要借助于Spring提供的HandlerMapping定位到具体的Controller。 HandlerMapping是这样一种对象，它能够完成客户请求到Controller之间的映射。 在Struts中，这种映射是通过struts-config.xml文件完成的。 其中，Spring为Controller接口提供了若干实现， 例如Spring默认使用的BeanNameUrlHandlerMapping。 还有，SimpleUrlHandlerMapping，CommonsPathMapHandlerMapping。 Spring Controller将处理来自DispatcherServlet的请求。 Spring的Controller类似于struts的Action， 能够接受HttpServletRequest和HttpServletResponse。 Spring为Controller接口提供了若干实现类， 位于org.springframework.web.servlet.mvc包中。 由于Controller需要为并发用户处理上述请求，因此实现Controller接口时， 必须保证线程安全并且可重用。Controller将处理客户请求， 这和Struts Action 扮演的角色是一致的。 一旦Controller处理完客户请求，则返回ModelAndView对象 给DispatcherServlet前端控制器。 ModelAndView中包含了模型（Model）和视图（View）。 从宏观角度考虑，DispatcherServlet是整个Web应用的控制器； 从微观角度考虑，Controller是单个Http请求处理过程中的控制器， 而ModelAndView是Http请求过程中返回的模型和视图。 前端控制器返回的视图可以是视图的逻辑名，或者实现了View接口的对象。 View对象能够渲染客户响应结果。其中，ModelAndView中的模型 能够供渲染View时使用。借助于Map对象能够存储模型。 如果ModelAndView返回的视图只是逻辑名，则需要借助Spring提供的 视图解析器（ViewResoler）在Web应用中查找View对象， 从而将响应结果渲染给客户。 DispatcherServlet将View对象渲染出的结果返回个客户。 思维导图如下:]]></content>
      <tags>
        <tag>javaEE</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BOS技术整合-03]]></title>
    <url>%2FBOS%E6%8A%80%E6%9C%AF%E6%95%B4%E5%90%88-03%2F</url>
    <content type="text"><![CDATA[@作者博客 SpringDataJpa原理分析和基本API 原理分析 Spring data 出现目的 为了简化、统一 持久层 各种实现技术 API所以 spring data 提供一套标准 API 和 不同持久层整合技术实现API jar 包 自己开发 Repository 只需要继承 JpaRepository 接口, 就可以享有父接口的功能CrudRepositorysave、 delete、 deteleAll、 findAll、 findOne、 countPagingAndSortingRepositoryfindAll(Sort) 基于排序的查询、 findAll(Pageable) 基于分页的查询 springDataJpa查询Query的使用 第一种 根据方法命名规则自动生成 1)基于一列查询等值查询 findBy 列名 例如： findByName(String name); 2)基于一列模糊查询 findBy 列名 Like 例如： findByNameLike(String name)3)基于两列等值查询 findBy 列名 And 列名 例如： findByUsernameAndPassword(String username, String password )第二种 不按命名规则写的查询方法，可以配置@Query 绑定 JPAL 语句或者 SQL 语句 第三种 不按命名规则写的查询方法 配置@Query 没写语句，实体类 @NamedQuery 定义 SpringDataJpa修改操作Query使用 使用@Query 注解完成 ， 搭配使用@Modifying 标记修改、删除操作将记录 1 的 最小长度改为 15 注意:方法参数位置顺序,如果在sql语句中参数没有标明位置,那么需要方法参数对调.注意： 使用单体测试，测试 DAO ，要添加事务，设置事务不回滚 datagrid分页 分页的分析: 请求数据： page 页码、 rows 每页记录数响应数据： total 总记录数、 rows 当前页数据记录分页列表查询实现 添加 pageQuery 方法页面会自动发送两个请求参数 page 页码、 rows 每页记录数 Spring data jpa 提供 分页查询方法 ，接受 Pageable 参数 提供 PageRequest 对象实现 Pageable 接口 编码流程1.修改 standard.html 数据表格 url 参数2.在 StandardAction 添加 pageQuery 方法 1)pom.xml 导入 json 插件 2)Action中使用json插件需要继承json-default 3)设置结果集的type=”json” 4)将结果集压人值栈顶部3.接口StandardService中的方法Page findPageData(Pageable pageable);4.实现类StandardServiceImpl中的方法 public Page findPageData(Pageable pageable) { return standardRepository.findAll(pageable); } 收派标准修改功能实现 注意: 修改只能对一行进行修改! 点击 修改按钮,获取 gatagrid 选中的一行数据 将选中数据 回显 form 表单使用 jquery easyui 提供 form 对象 在用户点击保存的时候,为这个按钮添加点击事件(click)操作判断 所有表单对象都通过校验通过,就提交不通过,就弹窗,警告! 数据表格datagrid简单使用 datagrid可以使用JS控制生成,也可以在页面元素table标签上定义,那么咱们先看在页面使用table元素需要注意的三个 在table标签class=”easyui-datagrid” 在table标签 data-options=”url:’datagrid_data.json’,fitColumns:true,singleSelect:true 在table标签内th data-options=”field:’code’,width:100” 其中filed指的是json文件中对应的字段名称 JS控制datagrid在页面显示表格的位置 提供标签，指定 id 元素 在 JS 代码 $(“#grid”).datagrid({…}); 完成对表格设置 远程数据加载(url:”product.json”) 分页(pagination:true):数据只有做成动态的数据分页才有实际效果 快递员的CRUD 添加 &lt;input type=&quot;text&quot; name=&quot;standard.id&quot; class=&quot;easyui-combobox&quot; data-options=&quot;required:true,valueField:&#39;id&#39;,textField:&#39;name&#39;, url:&#39;../../standard_findAll.action&#39;&quot;/&gt; //url 请求地址 查询 Action 层代码 Service 层代码 还原快递员(同理跟作废相反即可) 作废快递员 Action 层 Service 层 Dao层 前端请求 思维导图如下: © 著作权归作者所有 转载请保留原链接地址 @作者博客]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hibernate的二级缓存]]></title>
    <url>%2FHibernate%E7%9A%84%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[@作者博客Hibernate的二级缓存 二级缓存(外置缓存) 可以跨多个session，即不同的session都可以访问缓存数据 一级缓存(内置缓存) - Hibernate的一级缓存就是指Session缓存 - 在Session中定义了一系列的集合来存储数据，它们构成了Session的缓存。只要Session没有关闭，它就会一直存在。当我们通过Hibernate中的Session提供的一些API例如save()、get()、update()等进行操作时，就会将持久化对象保存到Session中，当下一次再去查询缓存中具有的对象(通过OID值来判断)，就不会去从数据库中查询了，而是直接从缓存中获取。Hibernate的一级缓存存在的目的就是为了减少对数据库的访问。 三种状态 瞬时状态：使用new操作符初始化的对象的状态就是瞬时的， 持久状态：在session的缓存中， 脱管状态：从session的缓存中移除出来了 工作流程 当Hibernate根据ID访问数据对象的时候，首先会从Session一级缓存中查找，如果查不到并且配置了二级缓存，那么会从二级缓存中查找，如果还查不到，就会查询数据库，把结果按照ID放入到缓存中。 Hibernate的二级缓存作为一个可插入的组件在使用的时候也是可以进行配置的，但并不是所有的对象都适合放在二级缓存中 在我实际开发中,如果 是很少被修改的数据,不是很重要的数据,都放入二级缓存中 而那些经常修改的数据,还有绝对不允许出现并发的,还有与其他应用共享的数据,都不会放入二级缓存 © 著作权归作者所有 转载请保留原链接地址]]></content>
  </entry>
  <entry>
    <title><![CDATA[Spring的两大特征和事务管理]]></title>
    <url>%2FSpring%E7%9A%84%E4%B8%A4%E5%A4%A7%E7%89%B9%E5%BE%81%E5%92%8C%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[@作者博客Spring 两大特性IOC控制反转 IOC是什么? IOC是一种思想,是一个重要的面向对象编程的体现之一 传统的应用程序是由我们在类的内部主动创建依赖对象,从而导致类与类之间高耦合,测试也繁琐. 相对于IOC而言,它是把创建和查找依赖对象的控制器交给了容器,有容器进行注入组合对象,所以对象与对象之间是,低耦合的,便于测试,而且也使得整个体系架构变得更灵活 IOC的面向对象思想就好像 ,百度百科上对这点描述是“不要给我们打电话，我们会给你打电话(don‘t call us, we‘ll call you)”这是著名的好莱坞原则;其实说简单一点,就是对象找依赖并注入,而不是对象自己主动去找 IOC依赖注入 在控制反转中获取资源的过程叫做依赖注入 构造器注入:123456789 这种方式的注入是指带有参数的构造函数注入 在XML文件中 配置注入对象``` - setter注入``` * 要写被注入对象的Set方法 * 在XML中配置 ,要注入的具体对象(是由Spring管理的对象) * 在Spring的xml配置文件中,配置相关的Bean(也叫托管),由Spring来管理对象 * 也是在配置好 Bean 以后,由Spring自动注入 AOP面向切面编程(可以说是,补全了OOP(面向对象编程)的不足的地方) 举个例子,日志功能,它往往是遍布在所有对象层中,而它又在核心功能中毫无关系,这种被散布在各处无关的代码 被称为横切,在oop设计中,它导致了大量代码的重复; AOP技术却相反,它利用一种 叫 “横切”的技术,解剖开封装的对象内部,并将影响了多个类的公共行为封装到一个版块,这个版块叫 “Aspect(啊死拜)”,又称切面. 切面,简单的说,就是那些与业务无关的,却又不可少的那一部分,封装起来,减少系统的重复代码,减低各个版块直接的耦合度,有利于维护和可操作性 AOP把软件系统分为两个部分：核心关注点和横切关注点 业务处理的主要流程是核心关注点 与之关系不大的部分是横切关注点 AOP核心概念 横切关注点 切面（aspect） 连接点（joinpoint） 切入点（pointcut） 通知（advice） 目标对象 织入（weave） 引入（introduction） 声明式事务管理 声明式事务管理建立在AOP之上的 其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务 声明式事务最大的优点就是不需要在代码中写管理事务的代码只需在配置文件中声明和配置事物管理即可(或通过基于@Transactional注解的方式) 思维图如下: @作者博客]]></content>
      <tags>
        <tag>javaEE</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[websevice的原理及使用方法]]></title>
    <url>%2Fwebsevice%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[@作者博客WebSerivce是什么? WebService是基于网络的、分布式的模块化组件。(是通过XML和Http协议为基础,进行通信的框架) 优势 跨平台 。 任何平台都可以使用WebService 编程语言无关系。 基于XML，XML本身与平台无关 部署、升级和维护Web服务简单、方便。 实现多数据、多服务的聚合 不受防火墙的影响(XML文件 转为二进制发送,不需要多开端口) 成本低(免费) 主要分为两种服务提供方式WS 、RS,两种方式底层通信协议不同 JAX-WS传输的就是xml格式的数据,基于soap协议 JAX-RS传输的是xml或者json的数据, 基于http协议 工作流程1.客户端调用 服务端提供的接口 2.服务端WebService处理 请求,调用WebService响应方法 3.服务器返回数据给客户端 使用方法WS 服务 创建WebService项目以后,导入CXF的jar 包支持 再编写服务的接口上,加上 @WebService (表示 服务提供对象) 在接口的方法上加上 @WebMethod (表示服务提供方法) 编写客户端测试,发布服务,测试访问地址是否有效 RS服务 在接口上加 @Path 服务访问资源路径 在方法上加 @Path 方法访问路径 在方法上加 @GET 查询 @PUT 修改 @POST 增加 @DELETE 删除 在方法上 @Consumes 指定能够处理客户端传递过来数据格式 在方法上 @Produces 指定能够生成哪种格式数据返回给客户端 同样的编写客户端代码,测试 注意!!(开发常用的是RS风格的WebService) 思维导图如下 (@博客): @作者博客]]></content>
      <tags>
        <tag>javaEE</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hashtable和HashSet的区别]]></title>
    <url>%2FHashtable%E5%92%8CHashSet%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[作者博客@Stone原地址 HashMap和Hashtable都实现了Map接口 但决定用哪一个之前先要弄清楚它们之间的分别 主要的是线程安全性，同步(synchronization)，以及速度 区别 HashMap是非synchronized的，并可以接受null (HashMap可以接受为null的键值(key)值(value)，而Hashtable则不行)。 HashMap是非synchronized，而Hashtable是synchronized,这意味着Hashtable是线程安全的，多个线程可以共享一个Hashtable； 而HashMap如果没有正确的同步的话，多个线程是不能共享HashMap的 由于Hashtable是线程安全的也是synchronized，所以在单线程环境下它比HashMap要慢。如果你不需要同步，只需要单一线程，那么使用HashMap性能要好过Hashtable。 重要的说一下他们存储空值出现的问题 Hashtable中，key和value都不允许出现null值。但是如果在Hashtable中有添加空值得操作,编译是会通过,但是在运行的时候就会,抛出NullPointerException异常，这是JDK的规范规定的。 HashMap中，null可以作为键，但是null的key键只能有一个 而这个时候要注意,不能用get()方法,来判断 HashMap中是否存在某个键， 而应该用containsKey()方法来判断 他们哈希值的使用不同，HashTable直接使用对象的hashCode。而HashMap重新计算hash值。 hashCode是jdk根据对象的地址或者字符串或者数字算出来的int类型的数值 而HashMap重新计算了key的hash值 (!这里我也不知道对不对)内部实现使用的数组初始化不同 HashTable在不指定容量的情况下的默认容量为11，而HashMap为16 如何让HashMap 安全列? 最好,也是最常用的是,让HashMap的线程安全,那就给它加死锁(同步) 思维导图如下(作者博客@Stone原地址):]]></content>
      <tags>
        <tag>javaEE</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hibernate中get和load的区别]]></title>
    <url>%2FHibernate%E4%B8%ADget%E5%92%8Cload%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[作者博客@Stone原地址 在Hibernate中如果要从数据库中得到一个对象 两种方法 通过session.get()方法 通过session.load()方法 区别 load加载方式 当使用load方法来得到一个对象时，此时hibernate会使用延迟加载的机制来加载这个对象 当使用session.load() 方法加载一个对象的时候,并不会发出SQL语句,这个对象其实就是一个代理对象,而这个代理对象只是保存实体对象的id值,只有当我们使用这个对象,得到其他属性的时候,这个时候才会发出SQL语句,从数据库中查询相对于的对象 get加载方式 相对于load的延迟加载方式，get就直接的多，当我们使用session.get()方法来得到一个对象时，不管我们使不使用这个对象，此时都会发出sql语句去从数据库中查询出来： 如果对象不存在（报错区别） 如果这个对象不存,通过get方式,去数据库中查询出该对象，但是这个不存在,所以id值页不存在，所以此时对象是null，所以就会报NullPointException的异常了(空指针异常)。 如果使用load方式来加载对象，当我们试图得到这个不存在的对象 的id值的时候，此时会报ObjectNotFoundException异常(对象未找到异常) 对象都不存在为什么报的异常不同? 是因为load的延迟加载机制，使用load时，此时的user对象是一个代理对象，仅仅保存了当前的这个id值，当我们试图得到该对象的username属性时，这个属性其实是不存在的，所以就会报出ObjectNotFoundException这个异常了 思维导图如下：作者博客@Stone原地址]]></content>
      <tags>
        <tag>javaEE</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用命令以及war包部署]]></title>
    <url>%2FLinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8Awar%E5%8C%85%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[Linux常用命令以及项目部署 常用命令 ls命令 ls -a 列出目录所有文件，包含以.开始的隐藏文件 ls -l t*列出当前目录中所有以“t”开头的目录的详细内容 列出文件绝对路径（包含隐藏文件）1find $pwd -maxdepth 1 | xargs ls -ld cd命令 切换当前目录 （1）进入要目录 cd / （2）进入”家”目录 cd ~ pwd命令 查看当前工作目录路径 mkdir 创建文件夹 mkdir -p 如果指定目录不存在 则创建目录 rm命令 删除一个目录中的一个或多个文件或目录，如果没有使用- r选项，则rm不会删除目录 删除test子目录及子目录中所有档案删除,并且不用一一确认 rm -rf test 删除以-f开头的文件 rm – -f*rmdir命令 从一个目录中删除一个或多个子目录项!!! 注意：不能删除非空目录 mv命令移动文件或修改文件名 将文件test.log重命名为test1.txt mv test.log test1.txt cp命令将源文件复制至目标文件，或将多个源文件复制至目标目录。 locate命令locate通过搜寻系统内建文档数据库达到快速找到档案，数据库由updatedb程序来更新， find用于在文件树中查找文件，并作出相应的处理 chmod命令用于改变linux系统文件或目录的访问权限。 tar命令用来压缩和解压文件。tar grep 强大的文本搜索命令 命令格式： grep [option] pattern file|dir 常用参数： A n –after-context显示匹配字符后n行 B n –before-context显示匹配字符前n行 C n –context 显示匹配字符前后n行 c –count 计算符合样式的列数 top 显示进程 显示当前系统正在执行的进程的相关信息，包括进程ID、内存占用率、CPU占用率等 vim 文本编写命令 搭建1.在linux系统中 先创建JDK和tomcat软件的存放路径2.下载tomcat 和JDK3.用FTP传输工具 传输(我使用的filezilla)4.文件传输完成以后,再进入到/root 根目录下,/root 目录5.移动或者Copy 到创建好的JDK和tomcat文件夹6.解压,并安装7.配置 JDK 环境变量(Vim /ect/profile)8.刷新环境变量 source /etc/profile9.配置tomcat环境变量 source /etc/profile 然后 再把工程 Copy 到 tomcat的 webapps下面 然后启动tomcat (就可以了)]]></content>
      <tags>
        <tag>javaEE</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程和进程的区别?以及如何实现多线程]]></title>
    <url>%2F%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB-%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[简单的来说 一个程序至少有一个进程,一进程至少有一个线程 线程的划分大小小于进程,所以使得多线程程序的并发性能高! 而且,进程在执行的过程中,有着自己独立的内存单元,而多个线程共享内存,从而极大的提高了程序的运行效率. 而他们的区别在于:每个独立的线程有一个程序运行入口,顺序执行序列和程序的出口. 但是线程不能够独立运行,必须是依赖程序,由程序提供多个个线程的执行控制! 从逻辑上看,多线程的意义在于一个程序中,有多个执行部分可以同时执行.但操作系统并没有将多个线程看做多个独立的应用,来实现进程的管理和资源分配,这是最重要的区别,也是最大的不同. 为什么这么说列?* 进程,是一个具有独立功能的程序,关于某个数据集合上的一次远行活动,进程是系统进行资源分配和管理的独立单位. * 线程是进程的一个实体,是cpu在调度和分配的基本单位. * 线程自己基本上不拥有系统的资源,它只是有一些运行必不可少的资源 但是它可以与同一进程中的其他线程共享进程所拥有的全部资源 !! 这同时也是 多线程的安全问题 因为多个线程同时访问同一个数据,而现在的cpu 主频,最低的也是1GHz吧, 也就是说 cpu 高达每秒几十亿的计算,你同一条数据,在 几个线程中,以几十亿的概率被几个线程同时访问,不出现安全性才怪! (如何解决此问题:把线程死锁就可以有效的避免,数据重复读取的问题了) 然后,创建线程有哪些方式? 刚才也说了,一个进程至少有一个线程,当我们不做任何的处理的时候,就是单进程. 而实现多线程 要么继承Thread类,创建线程子类重写run 方法,这个run方法的方法体就代表了线程要完成的任务,大部分javaee工程师,都喜欢叫这个方法体为,执行体(然后调用对象的,start()方法,启动该线程) 要么就实现Runnable 接口创建线程类一样的,重写run方法,start启动但是要注意:创建Runnable实例类的实例,是作为Thread的target来创建Thread对象的,这个Thread才是线程的真正对象. 思维导图如下:]]></content>
      <tags>
        <tag>javaEE</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本数据类型和引用数据类型的区别]]></title>
    <url>%2F%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[引用数据和基本数据的区别基本数据类型 Int,long,long,float,double,short,boolean,char,byte 引用数据类型: 类,接口,数组,枚举,注解类型 区别 从概念方法来说:基本数据类型:变量名指向具体的数值 ,引用数据类型:变量名指向存数据对象的内存地址,即变量名指向hash值 从内存方法 基本数据类型在被创建时，在栈上给其划分一块内存，将数值直接存储在栈上。 引用数据类型在被创建时，首先要在栈上给其引用（句柄）分配一块内存，而对象的具体信息都存储在堆内存上，然后由栈上面的引用指向堆中对象的地址。 数据类型在 栈和堆中的区别 静态区： 保存自动全局变量和 static 变量（包括 static 全局和局部变量）。静态区的内容在总个程序的生命周期内都存在，由编译器在编译的时候分配。 堆区： 一般由程序员分配释放，由 malloc 系列函数或 new 操作符分配的内存，其生命周期由 free 或 delete 决定。在没有释放之前一直存在，直到程序结束，由OS释放。其特点是使用灵活，空间比较大，但容易出错 栈区： 由编译器自动分配释放，保存局部变量，栈上的内容只在函数的范围内存在，当函数运行结束，这些内容也会自动被销毁，其特点是效率高，但空间大小有限 思维导图如下:]]></content>
      <tags>
        <tag>javaEE</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList和LinkedList的区别]]></title>
    <url>%2FArrayList%E5%92%8CLinkedList%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[大致的区别: ArrayList是实现了基于动态数组的数据结构, LinkedList基于链表的数据结构 对于随机访问get和set,ArrayList优于LinkedList,因为ArrayList可以随机定位,而LinkedList要移动指针一步一步的移动到节点处(举例:因为ArrayList的底层是动态数组,它属于一个对象,而LinkedList是链表,它是跟很多对象有关联的,所以, 你查询的话,数组就很快了,相对Linked而言,它联系着很多的对象,查询的时候,你要把他们都查出来,这个时候从性能和时间上,linkedList就不如ArrayList!) 对于新增和删除操作add和remove，LinedList比较占优势，只需要对指针进行修改即可，而ArrayList要移动数据来填补被删除的对象的空间。(ArrayList在添加和删除的时候,底层是创建一个新的数组,而LinkedList却只要修改一下指针就ok了) 什么时候用哪个?首先ArrayList和linkedList 是两个集合类,用于存储一系列的对象引用 1.ArrayList的内部实现是基于基础的对象数组的，因此，它使用get方法访问列表中的任意一个元素时(random access)，它的速度要比LinkedList快 2.LinkedList中的get方法是按照顺序从列表的一端开始检查，直到另外一端。对LinkedList而言，访问列表中的某个指定元素没有更快的方法了。 3.当操作是在一列数据的后面添加数据而不是在前面或中间,并且需要随机地访问其中的元素时,使用ArrayList会提供比较好的性能； 4.当你的操作是在一列数据的前面或中间添加或删除数据,并且按照顺序访问其中的元素时,就应该使用LinkedList了。 所以, 简单的来说业务如果查询多,就用ArrayList业务添加或者删除的多 就用 linkedList 思维导图如下:]]></content>
      <tags>
        <tag>javaEE</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[专场]]></title>
    <url>%2F%E7%8C%8E%E5%9C%BA-%E4%B8%93%E5%9C%BA%2F</url>
    <content type="text"><![CDATA[最新的猎场可谓是火到爆炸啊!可惜有些小伙伴们,想听得 “一场恋爱”需要付费! 今天就给小伙伴们分享一下,下载链接!为了让遗憾不再是遗憾,为了,小伙伴们,更加激情的 追 &lt;&lt;猎场&gt;&gt; 一场念爱 《猎场》电视剧片尾曲下载地址:高级音质无损音质 还有一个好听的音乐专辑哟! 给小伙伴们分享一下: Katy perry-Witness 整个Witness 专辑 会在后期更新! 到时候,更新会发布在最后,如果下载出现问题的小伙伴们,可以单独找我要!我会在看到消息的第一时间发给你哦!@Stone QQ :993166015]]></content>
      <tags>
        <tag>音乐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[装逼神器]]></title>
    <url>%2F%E8%A3%85%E9%80%BC%E7%A5%9E%E5%99%A8%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[BOS技术整理-02]]></title>
    <url>%2FBOS%E6%8A%80%E6%9C%AF%E6%95%B4%E7%90%86-02%2F</url>
    <content type="text"><![CDATA[jquery easyui 总合 (直接看API文档 后期加上如何使用)Oracle 数据库安装配置使用 1 . 直接安装 3 . 打开服务 并尝试连接数据库 4 . 安装远程连接工具 PLSQLDeveloper 安装配置使用 2.在 PLSQL Developer 启动，配置 oracle instanceclient 目录 4、 默认 PLSQL Developer 连接 Oracle 使用客户端字符集 utf-8 ， 基于工具使用 SQL 插入中文有乱码问题，设置客户端字符集 gb2312 配置 环境变量NLS_LANG = SIMPLIFIED CHINESE_CHINA.ZHS16GBK 弹窗了,就表示成功了! 工具补充: Navicat Premium 安装和使用直接安装 Orcale 创建用户1 . 先进入 Orcale 命令行2 . 针对 BOS 系统建立新的用户 创建 bos/bos 账户， 授予角色 connect、resource 1234-- Create the user create user BOS identified by &quot;&quot; default tablespace SYSTEM temporary tablespace TEMP profile DEFAULT password expire; -- Grant/Revoke role privileges grant connect to BOS; grant resource to BOS; -- Grant/Revoke system privileges grant unlimited tablespace to BOS; Spring 环境搭建IOC 导入 context 依赖 beans、core、expressionAOP 导入 测试集成 Web 集成 配置监听器整合持久层框架 hibernate、jpa web.xml 配置 spring 监听器 src/main/resource 下 建立 applicationContext.xmlrc/main/resource 提供 config.properties 外部属性文件、log4j.properties 日志配置文件Spring Data JPA 代替了 Hibernate“CURD “ 但是和Hibernate一样实现DAO(数据)层的功能 “增删改查”Hibernate 实体类 生成表结构 —- 领域（Domain）驱动建模 这次使用的是驱动建模,传统的设计模式是: 先设计表,再创建实体123JPA 注解使用 @Entity 标明是实体类 @Table 映射表名称 123@Id 主键标识@GeneratedValue 自动生成主键的值@Column 设置映射数据表中列信息 1@Temporal 控制数据表保存日期哪个部分（日期、时间、日期时间） @OneToMany(mappedBy 相当于 inverse ) @ManyToOne 结合 @JoinColumn 添加一列外键 ![enter description here][13] @ManyToMany 一方写 mappedBy 放弃外键维护、另一方 @JoinTable 维护中间表 思维导图:]]></content>
      <tags>
        <tag>javaEE</tag>
        <tag>Oracle安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BOS技术整合-01]]></title>
    <url>%2FBOS%E6%8A%80%E6%9C%AF%E6%95%B4%E5%90%88-01%2F</url>
    <content type="text"><![CDATA[Git1.1. 什么是Git1.1.1. Git是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目1.2. Git常用命令1.2.1. 查看当前版本: git -version1.2.2. 查看当前状态 git status1.2.3. 提交文件 git commit -a1.2.4. 合并到远程代码库（首先要将远程库，pull到本地，否则不能push） git push 远程地址 master1.2.5. pull远程到本地 git pull 远程地址 master1.2.6. 设置 git ignore 过滤文件，.class 后缀文件不提交到远程$ echo .class&gt;.gitignore查看设置是否成功：$ cat .gitignore .class1.3. Git图形化界面操作1.3.1. 下载 TortoiseGit 图形化客户端安装1.3.2.1.3.3.1.3.4.1.3.5. 删除文件和文件对比操作 1.4. Git 的分布式版本控制特性：同一个仓库可以分布到不同的机器上1.4.1. 1 要有一个原始版本库1.4.2. 2 别的机器 可以 clone 原始版本库1.5. 从本地仓库恢复1.5.1. jquery easyui2.1. 介绍:2.1.1. jQuery EasyUI是一组基于jQuery的UI插件集合体，而jQuery EasyUI的目标就是帮助web开发者更轻松的打造出功能丰富并且美观的UI界面。开发者不需要编写复杂的javascript，也不需要对css样式有深入的了解，开发者需要了解的只有一些简单的html标签。2.2. 使用:2.2.1. 引入 easyUI首先，你需要包含一些js和css文件：2.2.2. 使用小图标 easyui预定义了一些图标css，这些css类可以显示图片背景（16×16）。使用这些类之前，需要包含： 2.2.3. 转换成Ajax表单 我们写一些jquery代码使表单以ajax方式发送。注意，当数据返回时，form插件的success函数激发，所以我们可以处理一点事情。$(‘#ff’).form({ success:function(data){ $.messager.alert(‘Info’, data, ‘info’); }}); Hibernate3.1. 介绍3.1.1. JPA(Java Persistence API)作为Java EE 5.0平台标准的ORM规范，将得到所有Java EE服务器的支持。JPA受到大家的一致好评。JPA作为ORM领域标准化整合者的目标应该不难实现。3.2. 注意事项3.2.1.必须使用javax.persistence.Entity注解或者在 XML映射文件中有对应的元素必须具有一个不带参的构造函数，类、方法和 需要持久化的属性不能声明为final；如果游离状的实体对象需要以值的方式进行传 递，如通Session bean的远程业务接口传 递，则必须实现Serializable接口；需要持久化的属性，其访问修饰符不能是 public，它们必须通过实体类方法进行访问。3.3. 注解3.3.1. @Entity将实体对象标注为一个实体，表示需要保存到数据库中，默认情况下类名即为表名，通过name属性显式指定表名，如处的name = “student”，表示Student保存到student表中。3.3.2. @Id 对应的属性是表的主键。3.3.3. @GeneratedValue主键生成策略3.3.4. @Column(name = “address”)属性对应的表字段3.4. 主要的API3.4.1. EntityManager实体对象由实体管理器进行管理，JPA使用javax.persistence.EntityManager代表实体管理器主要的方法EntityManager的主要方法 void persist(Object entity) void remove(Object entity) T merge(T entity) T find(Class entityClass, Object primaryKey) 3.4.2. QueryJPA使用Query接口代表一个查询实例。该接口拥有众多执行数据查询的接口方法。 ◆Object getSingleResult()：◆List getResultList()：◆int executeUpdate()：3.4.3. 查询语句 JPQL(Java Persistence Query Language)]]></content>
      <tags>
        <tag>javaEE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring整合SSH]]></title>
    <url>%2FSpring%E6%95%B4%E5%90%88SSH%2F</url>
    <content type="text"><![CDATA[SSH整合-XML 准备工作-导包（复制）标记: 优先级 1 SSh( struts &amp; hibernate&amp;Spring 的核心配置文件) Spring的 applicationContext.xml 核心配置文件 Struts 的 Struts.xml 核心配置文件 Hibernate的 Hibernate.cfg.xml核心配置 类的映射配置文件 XXX.hbm.xml Web.XML 中配置 所有框架的入口标记: 优先级 2 Struts的入口 在web.xml中配置的 (Struts过滤器) 过滤器对象是 由Struts提供的 “ StrutsPrepareAndExcuteFilter “ 123456789&lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt;&lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; Hibernate的入口 因为它是底层实现,所以不需要在web.xml中配置,最多也是交给Spring来托管 Spring的入口 在web.xml中配置 123456789 &lt;!-- 配置Spring上下文监听器 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 配置Spring配置文件的路径 --&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath*:applicationContext*.xml&lt;/param-value&gt;&lt;/context-param&gt; 思维导图如下:]]></content>
      <tags>
        <tag>javaEE</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[欢迎--Stone]]></title>
    <url>%2Fhello-world%2F</url>
    <content type="text"><![CDATA[终于完成博客的搭建了! 内心还是比较激动的!做个日记! 博客的第一天 Github 搭建成功!1$ 欢迎来到Stone的个人博客]]></content>
  </entry>
  <entry>
    <title><![CDATA[windowns 端口查询]]></title>
    <url>%2Fwindowns-%E7%AB%AF%E5%8F%A3%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[//查看端口号 查看所有的端口占用情况 netstat -ano 开始—-&gt;运行—-&gt;cmd，或者是window+R组合键，调出命令窗口 输入命令：netstat -ano，列出所有端口的情况。在列表中我们观察被占用的端口，比如是49157，首先找到它。 查看被占用端口对应的PID，输入命令：netstat -aon|findstr “49157”，回车，记下最后一位数字，即PID,这里是2720 继续输入tasklist|findstr “2720”，回车，查看是哪个进程或者程序占用了2720端口，结果是：svchost.exe 或者是我们打开任务管理器，切换到进程选项卡，在PID一列查看2720对应的进程是谁，如果看不到PID这一列,如下图： 则我们点击查看—&gt;选择列，将PID(进程标示符)前面的勾打上，点击确定。 这样我们就看到了PID这一列标识，看一下2720对应的进程是谁，如果没有，我们把下面的显示所有用户的进程前面的勾打上，就可以看到了，映像名称是svchost.exe，描述是，Windows的主进程,与上面命令查看的完全一致。 结束该进程：在任务管理器中选中该进程点击”结束进程“按钮，或者是在cmd的命令窗口中输入：taskkill /f /t /im Tencentdl.exe。]]></content>
      <tags>
        <tag>windows技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql-05]]></title>
    <url>%2Fmysql-05%2F</url>
    <content type="text"><![CDATA[mysql的外键和视图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179 -- 外键（新增） --创建表的时候增加外接：在所有的表字段之后使用 -- foreign key （外键字段） -- references （主键字段） 在新增表之后 修改表结构 alter table 表名 add[constraint] foreign key（外键字段） references(主表 主键字段); -- 删除外键 alter table 表名 drop foreign key 外键名; -- desc 表名 -- show create table 表名 -- 外键（默认约束） --默认的有倆点：一个对父表，一个对子表 对子表约束：如果对应的外键字段在父表找不到对应的匹配：那么操作会失败。 对父表约束：父表数据进行写操作（删和改：都必须涉及到主键本身） -- 外键 条件 1.外键要存在：首先必须保证表的存储引擎是innodb。 如果不是innodb，能成功但是没有约束效果！ 2. 外键字段的字段类型（列类型）必须与父表的主键类型完全一致 3.一张表的外接名字不能重复 4.增加外键的字段（数据已经存在），必须保证数据与附表主键要求对应 ---- 外键约束 外键的作用！ 外键约束有三种约束模式：都是对父表的约束 district ：严格模式（默认的人）父表不能删除或者更新一个已经被子表数据的引用的记录 cascade ： 级联模式 对应子表关联的数据也跟着呗删除 setnull ：置空模式 对应的数据（外键字段）被置空 foreign key（外键字段）references 父表（主键字段） on delete 模式 update 模式;------- 联合查询 将多次查询（多条 select 语句），在记录上进行拼接（字段不会增加） --【基本语法】： 多条select 语句结构：每一条select 语句获取的字节数必须严格一致 select 语句1 union[union 选项] select 语句2... union 选项： All：保留所有（不管重复） Distinct：去重(整个重复) 默认的； 意义： 1.查询一张表,但是需求不同： 2.多张表的结果完全一样的，保存的数据（结构）也一样的。 -- 联合查询 order by 的使用 在联合查询中：order by 不能直接使用,需要对查询使用括号才行！ 让order by生效 需要加 limit (select 语句1 sex order limit 99999) union (select 语句2 sex order by sex desc limt 999999 ); -- 子查询 sub query 一条select邮件内部包含了另外一条select语句 两种分类繁琐：按位置分类 ；安结果没类； From子查询： 跟在from 之后 where子查询： 出现在wehre 条件中 Exists： 在exists里面 按结果： 标量子查询：得到的结果是一行一列 列子查询：一行多列 行： 多列一行（多行多列） 上面几个出现的位置都是在where之后 表： 多行多列（出现的位置在from之后） --表量子查询 1.确定数据：获取所有的学生 select * from 学生表名 wheere 2.获取班级id： select id from 班级表 where 字段名=班级; select * from 表名 where id=any(select id from 表名); select * from 表名 where id=some(select id from 表名); select * from 表名 where id=all(select id from 表名); --行子查询 返回的结果可以是多行多列（一行多列） 1.确定数据源 select * from 表名 where 条件？ 2.最大年龄和最高身高！ select max(age),max(height) from 表名; -- mystudent 学生表 select * from mystudent where --行元素(age,height) (age,height)=(select max(age),max(height) from 学生表); --表子查询 返回的结果是多行多列的二维表：子查询的结果可以当做二维表来使用！ 需求：找出每个班最高的一个学生 1.确定数据源：先将学生按身高进行降序！ 2.每个班选出第一个学生 select * from mystudent group by cid Select * from (select * from mystudent order by heigfht desc )&apos;身高&apos;group by cid; --EXISTS 查询 -- 所有的查询都需要先找到 数据源！； Exists： 是否存在的意思，exists 子查询就是用来判断某些条件是否满足； -- select exists（select * from 存在的表）; -- 返回 1; select * from mystudent where exists(select * from myclass) -- 视图（创建） view ：有结构但是没结果的虚拟表！ 基本语法： create view 视图名字 as select语句;-- 可以是普通查询； 创建单表视图：基表 create view 视图名字 as select * from 表名; 创建多表视图： create view 视图表名 as select *（注意这里不能有重复的字段名出现） from 表名 as inner join 表名 on 相同条件！！ -- 视图查看 --- 的结构 --表的所有查看方式都适用 view 查看表 show create view 结构表名\G; --视图一旦创建：系统会在视图对应的数据库文件夹下创建一个对应的结构文件: fm 文件 -- 修改视图 alter view 视图名字 as 新的 select语句 -- 删除视图 Drop view 视图名字; -- 视图操作（新增） 视图数据操作： --多表视图不能删除数据 -- 单表视图可以删除 delete from 视图名 where 条件; -- 视图更新 --第5天 25 ？？？？？？？？？？？？ -- 算法 undefined：未定义（默认的） Temptable：零时表 先执行视图的select 语句； merge：合并算法！25------------- 没学...]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql-04]]></title>
    <url>%2Fmysql-04%2F</url>
    <content type="text"><![CDATA[多表&amp;连接查询 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960-------------- 连接查询SQL 中 将连接查询分成了四类 内连接 外连接 自然连接 交叉连接 /* 连接查询：join 左表 ： 左表 join 右表 ： join 右表*/ -- 交叉链接 cross join 基本语法：左表 cross join 右表; ===== from 左表，右表; -- 内连接 左表[inner] join 右表 on 左表.字段=右表.字段 on 表示连接条件 select * from 表 as a inner join 表 as s on a.id=s.id; 内链接没有on 条件 又成了 笛卡尔积！ 内连接可以用 where 代替 on （where 没有 on 效率高） -- 外链接 outer join 以某张表为主 left join 左外链接 左连接 right join 右外链接 右连接 基本语法： 左表 left / right join 右表 -- 自动连接 natural join 自动匹配连接条件： 系统以字段名字作为匹配模式（同名字段就作为条件，多个同名，多个条件） 改名字： alter table 表名 change 字段名 新字段名 类型（varchar） not null； 自动使用同名作为字段连接条件。 自然外链接 select * from 表 natural left join 表; 左表left/right/inner join 右表 using(字段名);-- 使用同字段作为连接条件 自动合并条件]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql-03]]></title>
    <url>%2Fmysql-03%2F</url>
    <content type="text"><![CDATA[高级查询 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318 ----- 字段属性： 主键：primary key 主键 唯一约束；不能重复 在创建表的时候，在后面加 primary key 关键字 -- 追加主键 alter table 表名 modify 字段名 primary key alter table 表名 add primary key(字段名); --更新&amp;删除主键 alter table 表名 drop primary key; --主键分类 id int primary key comment &apos;逻辑主键&apos; ------ 自动增长 不给值或者给NULL的时候，会自动被系统+1操作 --自增长通常跟主键搭配 auto_increment 1.任何一个字段要做自增长前提是本身是一个索引(Key 拦有值) 2.必须是int型 3.一张表只能有一个自增长 default NUll 不给值 都会触动自增长 ----列属性（修改自增长） 向下修改不生效 向上修改生效 alter table 表名 auto_increment = 值; 查看字增长变量 show variables like &apos;auto_increment%&apos;; -- 修改自增长步长 set auto_increment_increment=5;--一次自增5-- 删除自增长 字段的一个属性，可以通过 modify 进行修改（没有 auto_increment） Alter table 表名 modify 字段 类型; alter table 表 modify id int; --查看 desc 表名 -- 列属性（唯一键） unique key --唯一键 数据不能重复,可以有多个唯一，允许为空。 本质与主键差不多。 -- 增加唯一键 1.在创建表的时候，字段之后跟 unique / unique key; 2.在所有的字段之后。unique key(字段，字段); not null unique key --PRI 表中又没有主键 3.在创建表之后增加唯一 alter table 表名 add unique key (字段); --- 删除唯一键 先删除后新增 alter table 表名 drop unique key -- 错误的 alter table 表名 dropindex 索引名字; --------索引 几乎所有的索引都是建立在字段之上 根据某种算法，将已有得数据（未来可能新增的数据） --索引的意义 1.提示查询数据的效率 2.约束数据的有效性（唯一性等） Mysql中提供了多种索引 主键:primary key 唯一: unique key 全文: fulltext index 普通: index 全文索引，最大的问题是如何确定关键字 英文很容易：单词与单词之间有空格 中文很难：没有空格，中文可以各种随意组合(分词：sphinx) ---------------- 关系 一对一 一对多(多对一) 多对多 sqlserver 主表 外表 ---- 范式：减少数据冗余 1NF - 6NF ------- 1NF 第一范式：在设计表存储数据的时候，如果表中设计的字段存储的数据，在取出来使用之前 还血药额外的处理，不满足第一范式。 数据不需要再次拆封 -- 2NF /* 不允许出现部分依赖 在输出舍得的过程中，如果有复合主键 且表中又字段并不是由整个主键来确定， 而是依赖主键中的某个字段，存在字段依赖的部分问题 称之为：部分依赖 */ -- 3NF 不能出现传递依赖 --逆规范化 磁盘利用率与效率的对抗 就是增大空间，提高效率 -------------数据高级操作--------------------- 数据操作：增删改查 新增： insert into 表名【字段名】 values (值列表); 在数据插入的时候，假设主键对应的值已经存在，插入一定会失败！ -- 主键冲突 更新操作 insert into 表名【字段名】values(值列表) on dupllcate key update 字段=值; 替换 replace into 表名【字段名】values（值列表; -------蠕虫复制 复制创建表（表结构） create table 新表名 like 旧表名; 蠕虫复制：先查出数据，然后将查出的数据新增一遍 insert into 表名【字段列表】 select 字段列表 * from 数据表名（旧表） -- 蠕虫复制 成倍增长 insert into 自己 select * from 自己; 意义： 1.从已有表拷贝数据到新表中 2.可以迅速的让表中的数据膨胀到一定的数量级。测试表的压力已经效率 ---- 高级 更新数据 基本语法 update 表名 set 字段=值 |where 条件| 高级更新 update 表名 set 字段 =值 |where 条件| limit 更新数量| -- 把表中的 a 变成 c update 表 set 字段=&apos;c&apos; where 字段=&apos;a&apos; limit 3; !!!GBK 不区分大小写。 ---- 高级 删除数据 可以 通过 limit 来限制数量 delete from 表名【where 条件】【limit 数量】; 删除数据以后，自增长 思路:数据的删除是不会该表表结构，只能删除表后重建。 TRUNCATE 表名 -删除后，重置自增长 ------- 高级 数据查询（select 选项） 基本语法： select 字段列表 * from 表名 where 条件| 完整语法： select 字段列表 * from 数据源 where 条件 group by having order by limit; All:默认的，保留所有的结果 Distinct : 去重，将重复的去掉 -- 字段别名 字段名 [as] 别名; 不写 as 也行 --- 数据源 /* 从一张表中取出一条记录，去另外一张表中匹配所有的记录 而且保留 记录数和字段数 这种结果为：笛卡尔积（交叉连接） 没什么用，尽量不用 */ 子查询： select * from （select * from 表名）; -- 高级 where 子句 where 子句的目标用来判断数据，筛选数据 where 返回结果 0 或者 1 0 带表false 1带表true ; 运算符： &gt; 大于 &lt; 小于 &gt;= 大于等于 &lt;= 小于等于 != &lt;&gt; 不等于 = 等于 模糊查询里用到的： like between and in / not in 逻辑运算符： &amp;&amp;(and) 并 ||(or) 或者 !(not) 非 rand 取得一个0和1之间的随机数 floor 向下取整！ 1. select * from 表 where id=1 || id=3 || id=5; || || select * from 表 where id in(1,3,5); 2. select * from 表 where height&gt;=170 and heihgt&lt;=180; || || select * from 表 where height between 170 and 180; --------------- Group by 分组---------------- 聚合函数： COUNT() :统计分组后的记录数，每一组有多少条记录 Max() :统计每组中最大的值 Min() :统计最小值 AVG() :统计平均值 SUM() : 统计和 select 聚合函数,字段名 from 表名 group by 字段名多字段排序： --order by 放在语句最后select * from 表名 border by 字段名(desc/asc), group_concat(字段) 回溯统计：with rollup -- Having 子句 Having 字句 进行条件判断 having 能做 where 能做的几乎所有事情 但是where却不能 select 字段名 from 表名 group by 字段 having 条件 --- order by select * from 表名 order by 字段 desc/asc; -- limit 子句 limit 有两种使用方式。 只用来限制长度 ------ length：每页显示的数量 Offset：offset-(页码-1)*每页显示数量]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql-02]]></title>
    <url>%2Fmysql-02%2F</url>
    <content type="text"><![CDATA[mysql 数据类型,乱码处理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126 ----数据类型（列类型） 整数型和小数型 --整数型 五类： tinyint --迷你型 最多为256种 (常用) smallint --小整型 最多65536种 2个字节 mediumint --中整型 使用3个字节数存储 int --标准整形，使用4个字节存储 (常用) bigint --大整型 使用8个字节 -------- 小数型 会四舍五入 浮动型：小数点浮动，精度有限，会丢失精度 定定型：小数点固定，精度固定，不会丢失精度 -------- 浮点型 float 4 double 8------ 定点型 不会四舍五入 查看警告：show warnings; -------- 时间日期类型 datetime:时间日期 date : 日期 time ：时间（段） timestamp ： 时间戳 -------------字符串类型----UTF8 一个字符占3个字节--------------在SQL 中，将字符串类型分了6类： char , varchar,text,blob,enum,set --定长字符串 char 在定义结构的时候就已经定义了最终数据的存储长度 char(L)L代表length、可以存储的长度、单位为字符，最大长度值为255. --变长字符串 varchar 在分配空间的时候，按最大的空间分配，但是实际上最终用了多少，是是根据具体的数据来确定 Varchar(L) 理论长度是65536个字符 --文本字符串 如果数据量非常大，通常说超过255个字符就会使用文本字符串 存储数据的格式进行分类：text和blob text 存储文字 blob 存储二进制数据(通常不用) ------ 枚举字符串--------------- 枚举：enum 事先将所有可能出现的结果设计好 使用方式： 定义：enum(可能出现的元素列表); --证明字段存储的数据是数值：将2数据取出来+0就可以判断出原来的数据存的到底是字符串还是数值， ------------集合字符串 集合跟枚举类似：实际存储的是数值，而不是字符串（集合是多选的）、 在集合里面，所有的字符串都对应二进制 查询 select 列名+0,列名 from 表名 对应的位，位取反 ----------------Mysql记录长度------------Mysql中规定：任何一条记录最长不能超过65535个字节(varchar永远达不到理论值) uft8 下 varchar实际顶配：21884字节 GBK 下 varchar实际顶配：32766字节 --------------空属性 两个值：NULL（默认的）和 NOT NULL(不为空) 虽然是默认的。数据库基本都是字段为空。 空数据没有意义 create table myclass( name varchar(20) not null, room varchar(20) null )charset utf8; -------------------列描述 comment 描述 没有时间含义：是专门用来描述字段，会根据表创建语句保存； create table myclass( name varchar(20) not null comment &apos;姓名&apos;, money decimal(10,2) null comment &apos;钱&apos; )charset utf8; ---------------默认值 某一种数据会经常性的出现某个具体的值 show create table 表名 查看列描述 default 默认值 create table myclass( name varchar(20) not null comment &apos;姓名&apos; default &apos;男&apos;, money decimal(10,2) null comment &apos;钱&apos; default 0 )charset utf8;]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql-01]]></title>
    <url>%2Fmysql-01%2F</url>
    <content type="text"><![CDATA[认识mysql数据库 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335数据库基础：1.什么是数据库？ 数据库：database 存储数据的仓库 数据库：高效的存储和处理数据的介质 2.数据库的分类分为两种： 关系型数据库（SQL） 非关系型数据库（NOSQL：not only SQL） 3.不同的数据库阵营中的产品？关系型的数据库 大型：oracle DB2 中型：SQL-SERVER，MYsql 小型：access 等非关系型数据库：memcached，mongodb，redis4.区别？ 关系型数据库：安全（保存磁盘，基本不可能丢失）容易理解 非关系型数据库：效率高，不安全（断电丢失） d----关系型数据库---------1.什么是关系型数据库？ 是一种建立在关系模型（数据模型）上的数据库。 模型包含三个方面 数据结构: 二维表（列和行） 操作指令：所有sql语句 完整性约束：表（内数据约束），表与表之间约束（外键）2.关系型数据库：维护实体内部，实体与实体之间的联系如果表对应的某个字段没有值，但是系统还是会分配空间！------------关键字说明-------------------数据库：database数据库系统：DBS（Database system）是一种虚拟系统DBMS：database management system 数据库管理系统DBA：database administrator，数据库管理员行/记录：row/record。列/字段：column/field.------------------SQL 关系型数据库---------SQL:structured query language 结构化查询语言SQL分为三个部分 DDL：datadefinition language ，数据定义语言。 DML：数据操作语言；其中DML又分了一个DQL 数据查询语言 DCL：数据控制语言。主要负责权限管理（用户）grant，revoke SQL 是一种约束，但不强制（类似W3C）。 ------------Mysql数据库-------------Mysql数据库是一种c/s结构的软件： 客户端/服务器。 (服务器一直运行，客户端在需要使用的时候运行) 交换方式： 1.客户单链接认证：链接服务器，认证身份：mysql.exe -hpup mysql.exe -hlocalhost -p3306 -uroot -p 2.发送SQL指令 3.服务器接收SQL指令：处理SQL指令， 返回操作结果 4.客户端接收结果：显示结果 show databases--查看所有数据库 5.断开链接（释放资源，服务器并发限制） exit/quit/\q 退出 ------------------Mysql服务器对象--------------------将mysql服务器内部对象分成了四层：系统（DBMS）-&gt;数据库（DB）-&gt;数据表（Tabel）-&gt;字段（）--------------SQL的基本操作-------------- 基本操作：CRUD SQL的基本操作对象进行分类： 库操作，表操作，数据操作 基本语法 创建库 create Create database 数据库名字[库选项]; 库选项：用来约束数据库，分为2个选择项 字符集设定：charset/character set 具体字符集（存储编码格式）常用的字符集：GBK和UTF8 校对集设定：colate 具体校对集 --------- 创建数据库 create database only charset utf8 -- 创建关键字数据库 create database database charset utf8 --（SQL语句保存：只会告诉用户的大概位置，不会说明保存愿意（静默模式）） --创建中文数据库 create database 中国 charset utf8; -- 解决方案：告诉服务器当前中文的字符集是什么 中文：GBK set names gbk； create database 中国 charset utf8; 当创建数据库SQL语句执行之后，发送了什么？ destiny电脑 保存路径：C:\ProgramData\MySQL\MySQL Server 5.6\data 1. 在数据库系统中，增加了对应的数据库信息 2. 会在保存数据的文件夹下：data目录，创建一个对应的数据库名称的文件夹 3. 每个数据库下都有一个opt文件：保存了库选项 --校对集依赖字符集--------查看数据库 1.查看所有数据库：show databases; 2.查看指定的数据库：模糊查询 show databases like &apos;pattern&apos;; %:表示匹配多个字符 _:表示匹配单个字符 3.查看数据库的创建语句： show create database only; show create database ‘database‘; 只要需要用到关键字都得用反引号 -- 数据库在执行SQL语言之前会优化SQl；----------更新数据库 数据库名字不可以修改 数据库的修改选项：字符集合校对集（校对集依赖字符集） alter database 数据库名称[库选项] Charset/charcter set[=]字符集 collate 校对集 修改数据库 名 字符集 alter database only charset gbk; -----删除数据库 所有的操作中：删除是最简单 drop database 数据库名字 1.删除数据库之后 在数据库内部看不到对应的数据库 2.在对应的数据库存储的文件夹内：数据库名字对应的文件夹也被删除 （级联删除：里面的数据表全部删除） 注意：数据库的删除，不能乱删除。要备份再删除！ --------表操作 表与字段是密不看可分的。 ----新增数据表 create tabel[if not exists]表名( 字段名字 数据类型， 字段名字 数据类型--最后一行不需要逗号 )[表选项] if not exists:如果表名不存在，那么就创建，否则不执行创建代码：检查功能 表选项：控制表的表现 字符集：charset/character set 具体字符集； 校对集：collate 具体校对集； 存储引擎：engine 具体的存储引擎（innodb 和 myisam） 然后一个表的设计都必须设定数据库 创建表1. careat tabe if not exists （数据库名.）student( name varchar(10), gender varchar(10), number varchar(10), age int )charset utf8; 创建表2. 进入数据库环境 use 数据库名字； 先进入数据库，然后创建表 use 表名 use only create table class( name varchar(10), room varchar(10), sex varchar(2) )charset utf8; 创建表的SQL指令之后发生了什么（多了文件在对应数据库的文件夹下面） 1.指定数据库下已经存在对应的表 2.在数据库对应的文件夹下，会产生对应表的结构文件（跟存储引擎有关系） ------------查看数据表------------------------------------- 数据库能查看的分数，表都可以查看 1.查看所有表 show tables; 2.查看部分表 ： 模糊匹配 show tables like &apos;%关键字&apos; 3.查看表创建语句 show create table student\g ---\g 等价于 分号； show create table student\G ---\纵向 4.查看表结构：查看表中的字段信息 Desc / describe /show columns from 表名 -- 查看表结构 desc class; describe class; show columns from class; Type 列表类型 字段类型： 数据类型 Field 字段名字 NULL 列属性 是否允许为空 Key 索引类型（PRI主键）UNI唯一等 Default 列属性 大部分字段默认为NUll Extra 列属性：扩充（额外的）---------------修改数据表----------------- 表本身存在，还包含字段； 修改本身和字段 --修改表本身 表本身可以修改：表名和表选项 修改表名：rename table 老表名 to 新表名 --修改表选项：字符集，校对集合存储引擎 Alter table 表名 charset =GBK; --新增字段 Alter table 表名 add[column]字段名 数据类型[列属性][位置]; 位置：字段名可以存放表中的任意位置 First：第一个位置 after: 在哪个字段之后：after 字段名 ；默认是在最后一个字段之后 alter table my_student add column id int first; --修改字段：通常是修改属性还在数据类型 Alter table 表名 modify 字段名 数据类型【位置】【属性】; alter table student modify number char(10) after id; --重命名字段 Alter table 表名 change 旧字段 新字段 数据类型【属性】【位置】； --删除字段 alter table 表名 drop 字段名； ---删除数据表 drop table 表名1，表名2；--可以一次性删除多张表； ----------------数据操作----------------- 新增数据表 1. insert into 表名 values (值，值，值), (值，值，值) 2. 给部分字段插入数据 insert into 表名（字段列表）values （值，值），（值列表) ------查看数据 select * from 表名： [where 条件] --查看指定字段和条件数据 select 字段名 from 表名 条件-------更新数据 Update 表名 set 字段=值 【where 条件】--------删除 delete from 表名 【where 条件】 -------------------中文数据问题----------------------------------------------------------------------查看所有字符集 --基本上：服务器是万能，什么字符集都支持 show character set; -- 查看服务器默认的处理的字符集 show variables like &apos;character_set%&apos;; --修改服务器认为的客户端数据的字符集为：GBK set character_set_client =gbk; --修改服务器给定数据的字符集为GBK set character_set_results=GBK； 快捷方式： set names 字符集 set names gbk；-------------------------------校对集问题--------------------- 校对集：数据比较的方式 有三种方式 _bin：binary，二进制比较，取出二进制位，一位一位的比较，区分大小写 _cs: case sensitive 区分大小写 _ci: case insensitice 不区分大小写 查看数据库所支持的校对集：show collation; --- 创建表使用不同的校对集 create table my_collate_bin( name char(1) )charset utf8 collate uft8_bin; create table my_collate_ci( name char(1) )charset utf8 collate uft8_qeneral_ci; --排序查找 select * from 表名_bin order by 字段名; select * from 表名_ci order by 字段名： -----------------Web乱码问题------------- 动态网页由三个部分构成： 浏览器、apache 服务器（PHP）、数据库服务器 都有自己的 字符集（中文） 统一编码（三码合一）]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA['linux-mysql']]></title>
    <url>%2Flinux-mysql%2F</url>
    <content type="text"><![CDATA[特意查看了我的Linux版本$ sudo lsb_release -a显示如下：Distributor ID: UbuntuDescription: Ubuntu 16.04.1 LTSRelease: 16.04Codename: xenial 查看3306端口是否正常root@node1:~# netstat -an | grep 3306tcp 0 0 127.0.0.1:3306 0.0.0.0:* LISTEN注意：现在的3306端口绑定的IP地址是本地的127.0.0.1 修改Mysql配置文件（注意路径，跟之前网上的很多版本位置都不一样）root@node1:~# vim /etc/mysql/mysql.conf.d/mysqld.cnf找到bind-address = 127.0.0.1前面加#注释掉 重启Mysqlroot@node1:~# /etc/init.d/mysql restart[ ok ] Restarting mysql (via systemctl): mysql.service. 再次查看端口信息root@node1:~# netstat -an | grep 3306tcp6 0 0 :::3306 :::* LISTEN]]></content>
      <tags>
        <tag>javaEE</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[aop]]></title>
    <url>%2Faop%2F</url>
    <content type="text"><![CDATA[AOP : aspect oriented programming 面向切面 今天的演讲: aop 和oop的区别! 哎!没有讲好,在这里补充一下! AOP:AOP（Aspect Oriented Programming），即面向切面编程，可以说是OOP（Object Oriented Programming，面向对象编程）的补充和完善。OOP引入封装、继承、多态等概念来建立一种对象层次结构，用于模拟公共行为的一个集合。不过OOP允许开发者定义纵向的关系，但并不适合定义横向的关系，例如日志功能。日志代码往往横向地散布在所有对象层次中，而与它对应的对象的核心功能毫无关系对于其他类型的代码，如安全性、异常处理和透明的持续性也都是如此，这种散布在各处的无关的代码被称为横切（cross cutting），在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。AOP技术恰恰相反，它利用一种称为”横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为”Aspect”，即切面。所谓”切面”，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。使用”横切”技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事物。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。 AOP核心概念1、横切关注点对哪些方法进行拦截，拦截后怎么处理，这些关注点称之为横切关注点2、切面（aspect）类是对物体特征的抽象，切面就是对横切关注点的抽象3、连接点（joinpoint）被拦截到的点，因为Spring只支持方法类型的连接点，所以在Spring中连接点指的就是被拦截到的方法，实际上连接点还可以是字段或者构造器4、切入点（pointcut）对连接点进行拦截的定义5、通知（advice）所谓通知指的就是指拦截到连接点之后要执行的代码，通知分为前置、后置、异常、最终、环绕通知五类6、目标对象代理的目标对象7、织入（weave）将切面应用到目标对象并导致代理对象创建的过程8、引入（introduction）在不修改代码的前提下，引入可以在运行期为类动态地添加一些方法或字段 AOP可以通过预编译方式和运行期动态代理实现在不修改源代码的情况下给程序动态统一添加功能的一种技术，把散落在程序中的公共部分提取出来，做成切面类，这样的好处在于，代码的可重用，一旦涉及到该功能的需求发生变化，只要修改该代码就行，否则，你要到处修改，如果只要修改1、2处那还可以接受，万一有1000处呢。 最常用的AOP应用在数据库连接以及事务处理上。 实现模式可能为：代理模式+工厂模式 OOP面向对象编程技术的关键性观念是它将数据及对数据的操作行为放在一起，作为一个相互依存、不可分割的整体——对象。对于相同类型的对象进行分类、抽象后，得出共同的特征而形成了类。面向对象编程就是定义这些类。类是描述相同类型的对象集合。类定义好之后将作为数据类型用于创建类的对象。程序的执行表现为一组对象之间的交互通信。对象之间通过公共接口进行通信，从而完成系统功能。类中声明的public成员组成了对象的对外公共接口。1 简单来说就是以功能为解决问题的中心。]]></content>
      <tags>
        <tag>javaEE</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sping-第一天]]></title>
    <url>%2FSping-%E7%AC%AC%E4%B8%80%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[Spring 介绍!!!Spring是一个分层的一站式轻量级开源框架，也是一个容器框架。]]></content>
      <categories>
        <category>Spring框架</category>
      </categories>
      <tags>
        <tag>javaEE</tag>
        <tag>java</tag>
        <tag>Sping</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java-IO流]]></title>
    <url>%2Fjava-IO%E6%B5%81%2F</url>
    <content type="text"><![CDATA[► File：文件和目录名的抽象表示形式 ► 类的实例是不可变的 构造： File(File parent,String child); ► 根据指定的父路径和文件路径创建File对象 new File(File对象路径,”文件名”); l File(String pathname); l 将指定的路径名转成一个File对象 new File(“路径+文件名”); File(String parent,String child); 根据指定的父路径和文件路径创建File对象 new File(“路径”,”文件名”); J File常用功能: l 创建功能 § boolena createNewFile(); § boolean mkdir(); § boolean mkdirs(); l 删除功能 § boolean delete(); l 获取功能 § File getAbsoluteFIle(); § String getAbsolutePath(); § String getName(); § String getParent(); § File geparentFile(); § String getPath(); § long lastModified(); § long length(); l 判断功能 § boolean exists(); § boolean isAnsolute(); § booealn isDirectory(); § boolean isFile(); § boolean isHidden(); l 修改方法 § boolean renameTo(File dest); J 绝对路径:固定不可改变的路径,以盘符开头 J 相对路径:相对某个参照物,不能以盘符开头 l boolean createNewFile(); //创建文件 当指定文件不存在的时候创建文件并返回true,否则返回false l boolean mkdir() //创建文件夹 存在false,不存在true l boolean delte();//删除文件或者文件夹 成功true,失败false 注意:删除一个文件夹,这个文件夹下面不能有其他的文件和文件夹 l boolean exists();//判断文件是否存在 l boolean isAbsolute(); //判断FIle对象指向的路径是否是绝对路径 是 true 否 false l boolean isDirectory()//判断File对象指向的路径是否是文件夹 § true/false l boolean File();//判断是否是文件 l boolean isHidden();//判断是否是隐藏文件 ----*****************************---- l 获取功能 l File getAbsoluteFile();//获取对象 l String getAbsolutePath();//返回对像的路径(绝对路劲) l String getParent(); 放回创建File对象的时候给的路径 File getParentFile() long lastModified(); 返回最后一次修改的时间(毫秒值) long length();返回文件的字节数 Boolean renameTo(File dest); 将当期File对象所指向的路径修改为指定File所指向的路径 //注意: 修改的文件路径不能存在,如果存在则修改失败 K String[] list(); 返回当前路径下所有的文件和文件夹名称 !注意: 只有指向文件夹的File对象才可以调用该方法 K File[] listFiles(); l 返回的是File[] K Static File[] ListRoots(); l 返回的是一个File[]数组 File[]里村的是所又佩服 IO流的分类 - 流向 - 输入流 读取数据 FileReader 父类是：Reader - 删除流 写数据 FileWriter 父类是：Writer * 数据类型 - 字节流 - 字节输入流 读取数据 InputStream - 字节输出流 写出数据 OutputStream + 字符流 - 字符输出流 读取数据 Reader - 字符输出流 写出数据 Writer 字节流 可以读和写入 不是文本对象的数据 字符流 只能写入和读取，文本对象的数据 (读数据的时候就出现的了问题)]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>文件写入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Session机制Cookie]]></title>
    <url>%2F2%2F</url>
    <content type="text"><![CDATA[Session生命周期已经Cookie的区别 简述: 会话(Session) 用来跟踪用户的整个回话 Cookie&lt;哭亏&gt; 而HTTP协议:是一种无状态的协议(无状态就是:对于你之前的操作,处理,没有记忆能力)一旦客户端和服务端数据交换完毕,客户端和服务端的连接就断开了.再次进行数据交互的时候,就需要重新建立连接.这就意味着,服务器无法从连接上同步用户的操作了! 就是用户A 把商品放入购物 是客户端和服务端的一次数据交换然后用户A结账的时候,又是一次数据交换!而在用户进行第二次数据交换的时候,服务端无法判断那个商品属于A! 所以要让服务器端跟踪(同步)用户的操作,就必须引入一种机制.而这种机制就是Cookie Ø 由于HTTP是一种无状态的协议,服务器无法在网络连接上知道用户的身份.怎么办?这个时候,就给每一个客户端发一个令牌!,每人一个.无论是谁访问都得带上它,而这样服务器就能从令牌上确认用户身份了.这就是Cookie的工作原理 Cookie 机制: 理论上，一个用户的所有请求操作都应该属于同一个会话，而另一个用户的所有请求操作则应该属于另一个会话，二者不能混淆. 例如: 用户A在超市买的任何商品,都应该是放入A的购物车中! 不论用户A 是什么时间买的! 这都属于同一个会话. 不可能你的买的东西,我来付钱,最后的东西还不在我的手上吧! Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态。 Session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。 Ø Session 机制 Session是服务器端使用的一种记录客户端状态的机制，使用上比Cookie简单一些，相应的也增加了服务器的存储压力。 客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session 客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。 如果说Cookie机制是通过检查客户身上的“令牌”来确定客户身份的话.那么Session机制就是通过检查服务器上的 &quot;身份证档案&quot;就确认用户的身份 Session相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了。 Ø 说一下Session的生命周期 为了获得更高的存取速度，服务器一般把Session放在内存里。每个用户都会有一个独立的Session。如果Session内容过于复杂，当大量客户访问服务器时可能会导致内存溢出 Session在用户第一次访问服务器的时候自动创建。需要注意只有访问JSP、Servlet等程序时才会创建Session 如果尚未生成Session，也可以使用request.getSession(true)强制生成Session Session生成后，只要用户继续访问，服务器就会更新Session的最后访问时间 如果用户过多,那么Session也会多 为防止内存溢出，是不是服务器就得把长时间没有访问过服务器的,Sesion给删除了。 Session的有效时间设置: 通过Session的属性, maxInactiveInterval(马克思应来特应赌博) Session的有效时间可以在web.xml中修改 Session的invalidate()方法可以使Session失效。 刚才也说了,Session是存在服务器的内存中的, 如果改变服务器,那么Session就没有了 虽然Session保存在服务器，对客户端是透明的，它的正常运行仍然需要客户端浏览器的支持。 因为Session需要使用Cookie作为识别标志。 Session不能依据HTTP连接来判断是否为同一客户，因此服务器向客户端浏览器发送一个名为JSESSIONID(塞醒ID)的Cookie，它的值为该Session的id（也就是HttpSession.getId()的返回值）。Session依据该Cookie来识别是否为同一用户。 * URL地址重写是对客户端不支持Cookie的解决方案。URL地址重写的原理是将该用户Session的id信息重写到URL地址中。服务器能够解析重写后的URL获取Session的id。这样即使客户端不支持Cookie，也可以使用Session来记录用户状态。HttpServletResponse类提供了encodeURL(Stringurl)实现URL地址重写 1234567cookie 和session 的区别：1、cookie数据存放在客户的浏览器上，session数据放在服务器上。2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗 考虑到安全应当使用session。4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。总结: Cookie通过在客户端记录信息确定用户身份，Session通过在服务器端记录信息确定用户身份。]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>javaEE</tag>
        <tag>java</tag>
        <tag>WEB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kali linux]]></title>
    <url>%2Fkali-linux%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>kali 黑客系统</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java开发常用架包]]></title>
    <url>%2F1%2F</url>
    <content type="text"><![CDATA[常用架包 java开发中主要用到的jar包描述 commons-io.jar：可以看成是java.io的扩展，用来帮助进行IO功能开发．它包含三个主要的领域:Utilityclasses-提供一些静态方法来完成公共任务．Filters-提供文件过滤器的各种实现．Streams-提供实用的Stream，reader与writer实现．commons-beanutils.jar：提供对Java反射和自省API的包装，主要提供了对于JavaBean进行各种操作。commons-digester.jar:它能方便地将XML文档所定义的元素转化为JAVA对象，其实它的用法有点象栈(当然内在的原理就是那个古老的东西,只是提供了更高一层的封装)。commons-lang.jar:它扩展了标准java.langAPI，增加了字符串操作方法、基本数值方法、对象反射、创建和串行化以及System属性。它还包含一个可继承的enum类型、对多种嵌套的Exception类型的支持、对java.util.Date的增强以及用于构建方法的实用程序，例如自动生成toString()的结果、自动实现hashCode()和equals()方法、数组操作、枚举、日期和时间的处理等等。• ArrayUtils–用于对数组的操作，如添加、查找、删除、子数组、倒序、元素类型转换等；• BitField–用于操作位元，提供了一些方便而安全的方法；• BooleanUtils–用于操作和转换boolean或者Boolean及相应的数组；• CharEncoding–包含了Java环境支持的字符编码，提供是否支持某种编码的判断；• CharRange–用于设定字符范围并做相应检查；• CharSet–用于设定一组字符作为范围并做相应检查；• CharSetUtils–用于操作CharSet；• CharUtils–用于操作char值和Character对象；• ClassUtils–用于对Java类的操作，不使用反射；• ObjectUtils–用于操作Java对象，提供null安全的访问和其他一些功能；• RandomStringUtils–用于生成随机的字符串；• SerializationUtils–用于处理对象序列化，提供比一般Java序列化更高级的处理能力；• StringEscapeUtils–用于正确处理转义字符，产生正确的Java、JavaScript、HTML、XML和SQL代码；• StringUtils–处理String的核心类，提供了相当多的功能；• SystemUtils–在java.lang.System基础上提供更方便的访问，如用户路径、Java版本、时区、操作系统等判断；• Validate–提供验证的操作，有点类似assert断言；• WordUtils–用于处理单词大小写、换行等。commons-codec.jar：包含一些通用的编码解码算法。包括一些语音编码器，Hex,Base64,以及URLencoder。commons-collections.jar：提供一个类包来扩展和增加标准的JavaCollection框架。• Bag接口：适用于包含一个对象的多个拷贝的集合• Buffer接口：适用于具有顺序的集合类，例如FIFOs(先进先出)• BidiMap(双向映射)：可以通过值查找键，也可以通过键查找值• Map迭代器：提供了对映射的快速迭代• 对类型检查进行了封装，确保特定类的实例可以被添加到集合中• 对转换进行了封装，将集合中的对象转换成被加入时的类型• 对集合进行组合，使多个集合看起来就像一个集合一样• 有序映射和set，保持元素添加时的顺序，包括一个基于LRU的map• 标识映射可以给予对象的==来比较对象，而不是基于equals方法• 引用映射可以允许键and/or值可以有控制的进行回收• 很多比较器的实现• 很多迭代器的实现• 从数组或者枚举到集合的适配器• 用来测试或者创建典型set理论的集合属性，例如与、或、闭包commons-dbutil.jar:对传统操作数据库的类进行二次封装，可以把结果集转化成List(1)org.apache.commons.dbutilsDbUtils :提供如关闭连接、装载JDBC驱动程序等常规工作的工具类QueryRunner:该类简单化了SQL查询，它与ResultSetHandler组合在一起使用可以完成大部分的数据库操作，能够大大减少编码量。QueryLoader:属性文件加载器，主要用于加载属性文件中的SQL到内存中。(2)org.apache.commons.dbutils.handlersArrayHandler：将ResultSet中第一行的数据转化成对象数组ArrayListHandler将ResultSet中所有的数据转化成List，List中存放的是Object[]BeanHandler：将ResultSet中第一行的数据转化成类对象BeanListHandler：将ResultSet中所有的数据转化成List，List中存放的是类对象ColumnListHandler：将ResultSet中某一列的数据存成List，List中存放的是Object对象KeyedHandler：将ResultSet中存成映射，key为某一列对应为Map。Map中存放的是数据MapHandler：将ResultSet中第一行的数据存成Map映射MapListHandler：将ResultSet中所有的数据存成List。List中存放的是MapScalarHandler：将ResultSet中一条记录的其中某一列的数据存成Objectjava开发中主要用到的jar包总结axis.jar:SOAP引擎包jaxrpc.jar:Axis运行所需要的组件包saaj.jar:创建到端点的点到点连接的方法、创建并处理SOAP消息和附件的方法，以及接收和处理SOAP错误的方法.wsdl4j-1.5.1.jar:Axis运行所需要的组件包activation.jar:JAF框架的jar包annotations-api.jar:使用注解所需jarant.jar:用于自动化调用程序完成项目的编译，打包，测试等aopalliance-1.0.jar:支持Spring AOPasm-2.2.3.jar:ASM字节码库asm-commons-2.2.3.jar:ASM字节码库asm-util-2.2.3.jar:Java字节码操纵和分析框架aspectjrt.jar:处理事务和AOP所需的包aspectjweaver.jar:处理事务和AOP所需的包axiom-api-1.2.7.jar:Axis 对象模型axiom-impl-1.2.7.jar:Axis 对象模型bcprov-jdk15-140.jar:基于java1.5 的加密算法实现bfmclientmodel.jar:使用WebSphere所需jar包bpcclientcore.jar:使用WebSphere所需jar包bpe137650.jar:提供远程访问BPE容器的实现。bsh-2.0b4.jar:解决负载逻辑运算c3p0-0.9.0.jar:开放源代码的JDBC连接池cglib-nodep-2.1_3.jar:Spring中自动代理所需jar包cobertura.jar:测量测试覆盖率commons-beanutils-1.7.0.jar:动态的获取/设值Java Bean的属性commons-chain-1.1.jar:实现责任链设计模式的Java 类库commons-codec-1.3.jar:用来处理常用的编码方法的工具类包，例如DES、SHA1、MD5、Base64等等commons-collections-3.1.jar:对标准java Collection的扩展commons-collections.jar:对标准java Collection的扩展commons-discovery-0.2.jar:用来发现、查找和实现可插入式接口，提供一些一般类实例化、单件的生命周期管理的常用方法.db2jcc.jarjava连接DB2所需jarcommons-digester-1.8.jar:用于处理struts-config.xml配置文件commons-fileupload-1.1.1.jar:struts上传文件commons-httpclient-3.1.jar:用来简化HTTP客户端与服务器端进行各种通信编程实现commons-io-1.1.jar:针对java.io.InputStream和Reader进行了扩展commons-lang-2.4.jar:对java.lang.的扩展commons-logging-1.1.1.jar:日志包commons-pool-1.3.jar:实现对象池化框架commons-validator-1.3.1.jar:用来把验证规则程序提取出来，以供重复使用db2jcc_license_cu.jar:java:连接DB2所需jardom4j-1.6.1.jar:解析XMLehcache-1.2.4.jar:hibernate的二级缓存如果用ehcache的时候需要此jar包emf.jar:基于Eclipse的模型框架ezmorph-1.0.6.jar:使用JSON所需的jar包FastInfoset-1.2.2.jar:使用WebService所需的jar包freemarker-2.3.8.jar:Strus2支持的一种表现层框架geronimo-activation_1.1_spec-1.0.2.jar:Apache Geronimo所带jar包，geronimo-annotation_1.0_spec-1.1.1.jar:Apache Geronimo所带jar包geronimo-javamail_1.4_spec-1.3.jar:Apache Geronimo所带jar包geronimo-jaxws_2.1_spec-1.0.jar:Apache Geronimo所带jar包geronimo-jms_1.1_spec-1.1.1.jar:Apache Geronimo所带jar包geronimo-servlet_2.5_spec-1.2.jar:Apache Geronimo所带jar包geronimo-stax-api_1.0_spec-1.0.1.jar:Apache Geronimo所带jar包hibernate3.jar:Hibernate3的核心jar包htmclientmodel.jar:使用WebSphere所需jar包jakarta-oro.jar:一套文本处理工具，提供per15.0兼容的表达式，AWK-like表达式，Glob表达式。javassist.jar:Javassist 字节码解释器jaxb-api-2.1.jar:使用WebService所需的jar包jaxb-impl-2.1.7.jar:使用CXF所需jar包jaxb-xjc-2.1.7.jar:使用CXF所需jar包jaxen-1.1.1.jar:解析XMLjcifs-1.2.22.jar:实现单点登陆jdom2-1.0.jar:解析XMLjdom-1.0.jar:解析XMLjettison-1.0.1.jar:使用CXF所需jar包jetty-6.1.9.jar:Jetty Http服务器jarjetty-util-6.1.9.jar:Jetty Http服务器jarjra-1.0-alpha-4.jar:使用CXF所需jar包js-1.6R7.jar:使用CXF所需jar包json-lib-2.2.3-jdk13.jar:使用JSON所需的jar包jsonplugin-0.25.jar:strus2的JSON插件jsr311-api-0.8.jar:使用CXF所需jar包jstl.jar:JSTL标签库jta.jar:标准的 JAVA 事务处理接口junit.jar:用于单元测试jxl.jar:通过java操作excel表格的工具类库ldap.jar:JNDI目录服务和LDAO服务器所需的jarldapbp.jar:JNDI目录服务和LDAO服务器所需的jarlog4j-1.2.15.jar:提供日志功能mail.jar:java发送邮件jar包neethi-2.0.4.jar:使用CXF所需jar包odmg-3.0.jar:ODMG是一个ORM的规范，Hibernate实现了ODMG规范，这是一个核心的库ognl-2.6.11.jar:struts2中OGNL语言ojdbc14.jar:Oracle数据库驱动包opensaml-1.1.jar:使用CXF所需jar包oro-2.0.8.jar:Validator框架所需的jar包oscache-2.1.jar:Java 对象的缓存工具poi-3.1-FINAL-20080629.jar:操作exce所需jar包poi-contrib-3.1-FINAL-20080629.jar:操作exce所需jar包poi-ooxml-3.6-20091214.jar:提供对office的word、excel、visio及ppt的操作poi-ooxml-schemas-3.6-20091214.jar:提供对office的word、excel、visio及ppt的操作poi-scratchpad-3.1-FINAL-20080629.jar:提供对office的word、excel、visio及ppt的操作processCommon.jarIBM WebSphere:运行所需jarProcessCommonLibrary.jarIBM WebSphere:运行所需jarprocessIdentity.jarIBM WebSphere:运行所需jarProcessInformation.jar:进程监视软件包proxool-0.9.1.jar:数据库连接池proxool-cglib.jar:数据库连接池quartz-1.6.0.jar:开源作业调度框架saaj-api-1.3.jar:使用axis所需的jarsaaj-impl-1.3.2.jar:使用axis所需的jarserializer-2.7.1.jar:XML序列化slf4j-jdk14-1.5.6.jar:整合各种日志框架的工具spring208.jar:spring核心框架spring-ldap-1.2-RC1.jar:spring下LDAPspring-mock.jar:spring的测试框架standard.jar:使用JSTL标签库所需的jarstax-api-1.0.1.jar:解析XMLstruts2-core-2.0.14.jar:struts2核心jarstruts2-spring-plugin-2.0.6.jar:struts2整合Spring所需jartaglibs-datetime.jar:Apache开源组织提供标签库，用于格式化日期。taglibs-mailer.jar:用于发送邮件taglibs-string.jar:Apache开源组织提供标签库，用于对String的操作。task137650.jar:Portal技术在SOA系统集成应用中实现所需的jarutility.jar:Apache开源组织提供标签库velocity-1.5.jar:一个免费的开源模板框架wsdl4j-1.6.2.jar:用来解析服务的WSDl文件wss4j-1.5.4.jar:创建CXF所需jarwstx-asl-3.2.6.jar:创建CXF所需jarxbean-spring-2.8.jar:使用xfire所需jarxerces-2.6.2.jar:XML解析器xfire-all-1.2.6.jar:用于实现WebServiceXmlSchema-1.1.jar:使用xfire所需jarxwork-2.0.7.jar:WebWork核心jar]]></content>
  </entry>
</search>
